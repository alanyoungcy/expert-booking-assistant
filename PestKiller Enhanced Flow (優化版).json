{
  "name": "PestKiller Enhanced Flow (å„ªåŒ–ç‰ˆ)",
  "nodes": [
    {
      "parameters": {
        "multipleMethods": true,
        "path": "booking-assistant",
        "responseMode": "responseNode",
        "options": {
          "rawBody": true
        }
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        17664,
        12272
      ],
      "id": "6d5c0eba-f8a2-4407-b052-2909d294b6a7",
      "name": "å®¢æˆ¶é ç´„è«‹æ±‚",
      "webhookId": "c327d4fc-c72c-42f9-94e0-75d17725a860"
    },
    {
      "parameters": {
        "url": "https://maps.googleapis.com/maps/api/distancematrix/json",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpQueryAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "origins",
              "value": "={{ $json._mapsParams.origins }}"
            },
            {
              "name": "destinations",
              "value": "={{ $json._mapsParams.destinations }}"
            },
            {
              "name": "key",
              "value": "AIzaSyCujmDrdlHgPEaKxtn8CbpBNPKwhXIDUKs"
            },
            {
              "name": "mode",
              "value": "driving"
            },
            {
              "name": "language",
              "value": "zh-HK"
            },
            {
              "name": "region",
              "value": "HK"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        18656,
        13056
      ],
      "id": "751c9eab-7d45-4dcd-8ac3-d2491f70c67b",
      "name": "è·å“¡åœ°å€",
      "credentials": {
        "httpQueryAuth": {
          "id": "aR4jbCmd9PeKCEqL",
          "name": "Google Map Distance Matrix"
        }
      }
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "89dd73ee-c857-47e4-900f-7b2d00c54b74",
              "name": "å“ç‰Œ",
              "value": "={{ $json.body.brandName }}",
              "type": "string"
            },
            {
              "id": "4c81d4bf-45c7-4550-9cb1-ae82a26b17a9",
              "name": "æœå‹™",
              "value": "={{ $json.body.serviceName }}",
              "type": "string"
            },
            {
              "id": "d252afa3-780c-4bb8-8bd7-cc770002e7da",
              "name": "åœ°å€",
              "value": "={{ $json.body.mainAreaName }}{{ $json.body.subAreaName }}",
              "type": "string"
            },
            {
              "id": "district-english-field",
              "name": "district",
              "value": "={{ $json.body.mainAreaName }}{{ $json.body.subAreaName }}",
              "type": "string"
            },
            {
              "id": "15d84e6e-ca7a-4e5a-a636-a3d7a6b3e857",
              "name": "å–®ä½å°ºæ•¸ (å¹³æ–¹å°º)",
              "value": "={{ $json.body.unitArea }}",
              "type": "number"
            },
            {
              "id": "bd35554c-258f-4205-9be8-7dff1dfdad13",
              "name": "å•é¡Œåš´é‡ç¨‹åº¦(1-5ç´š)",
              "value": "={{ $json.body.estimatedSeverity }}",
              "type": "number"
            },
            {
              "id": "6afc9dfc-0a38-47f0-99d0-c0058ae6bbfa",
              "name": "é ä¼°æœå‹™æ™‚é–“(åˆ†é˜)",
              "value": "={{ $json.body.manualEstimatedDuration }}",
              "type": "number"
            },
            {
              "id": "c8544051-dccd-4b0c-840a-f1ecd9f5601b",
              "name": "å›è¨ªä¸­é–“ç©ºæª”(å°æ™‚)",
              "value": "={{ $json.body.revisitDelay ? Number($json.body.revisitDelay) : 0 }}",
              "type": "number"
            },
            {
              "id": "8ed45f4e-4833-494c-86fe-77e45079f713",
              "name": "å›è¨ªåœç•™æ™‚é•·(åˆ†é˜)",
              "value": "={{ $json.body.manualRevisitDuration ? Number($json.body.manualRevisitDuration) : 0 }}",
              "type": "number"
            },
            {
              "id": "7d143fc1-3ad3-4e48-9301-fe8bbd6d80b0",
              "name": "å‚™è¨»",
              "value": "={{ $json.body?.notes ?? '' }}",
              "type": "string"
            },
            {
              "id": "c38aa744-3a55-444f-b16d-5ae03d399108",
              "name": "æäº¤æ—¥æœŸ",
              "value": "={{ DateTime.fromISO($json.body.timestamp).toFormat('yyyy-MM-dd') }}",
              "type": "string"
            },
            {
              "id": "23361f50-d6e4-4574-9f0c-4f11fe2f5236",
              "name": "æäº¤æ™‚é–“",
              "value": "={{ DateTime.fromISO($json.body.timestamp).toFormat('HH:mm') }}",
              "type": "string"
            },
            {
              "id": "morning-cleaning-field",
              "name": "æ—©ä¸Šæ¸…æ½”",
              "value": "={{ $json.body.morningCleaningOnly || $json.body.æ—©ä¸Šæ¸…æ½” || '' }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        17888,
        12288
      ],
      "id": "6cf37ae3-0d46-4724-beaf-e0ea55d1f312",
      "name": "æŠ½å‡ºå¿…è¦å­—æ®µ",
      "options": {
        "keepOnlySet": true
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * n8n Function node\n * Input: items[0].json åŒ…å« { appointments: [...] } æˆ– [ { appointments: [...] } ]\n * Output: æ¯å€‹é ç´„ä¸€å€‹ itemï¼Œä¸¦é™„åŠ ï¼š\n *  - prev_gap_minutes / next_gap_minutesï¼šèˆ‡å‰/å¾Œå–®ç©ºæª”åˆ†é˜ï¼Œè² å€¼è¡¨ç¤ºé‡ç–Š\n *  - prev_district / next_districtï¼šå‰/å¾Œå–®åœ°å€\n *  - prev_id / next_idï¼šå¯è¿½è¹¤ï¼Œæ–¹ä¾¿é©—è­‰\n */\n\nfunction pad(n){ return String(n).padStart(2, '0'); }\nfunction toDT(dateStr, timeStr, allDay){\n  if (!dateStr) return null;\n  const [Y,M,D] = dateStr.split('-').map(Number);\n  let h = 0, m = 0;\n  if (allDay) { h = 0; m = 0; }\n  else if (timeStr) { [h, m] = timeStr.split(':').map(Number); }\n  else { return null; }\n  return new Date(Y, M - 1, D, h, m, 0, 0);\n}\nfunction diffMin(a, b){\n  // returns (a - b) in minutes\n  return Math.round((a.getTime() - b.getTime()) / 60000);\n}\nfunction getDistrict(appt){\n  // å„ªå…ˆ labelï¼Œå…¶æ¬¡ä¸­æ–‡ï¼Œæœ€å¾Œè‹±æ–‡\n  return appt?.order?.district?.label\n      ?? appt?.order?.district?.name_zh\n      ?? appt?.order?.district?.name_en\n      ?? null;\n}\n\n// å–å¾— appointments é™£åˆ—\nconst inputItems = (typeof $input !== 'undefined' && $input.all) ? $input.all() : (typeof items !== 'undefined' ? items : []);\nlet root = inputItems[0]?.json;\nif (Array.isArray(root)) root = root[0];\nconst appts = root?.appointments ?? [];\n\n// å®šç¾©è¦æ’é™¤çš„é¡è‰²ç¢¼\nconst EXCLUDED_COLORS = ['#ed562e', '#e17e76'];\n\n//\n// 1) é è™•ç†ï¼Œè½‰æˆå¸¶æœ‰æ—¥æœŸç‰©ä»¶ï¼Œä¸¦éæ¿¾é¡è‰²ç¢¼\n//\nconst enriched = appts\n  .filter(a => {\n    // éæ¿¾æ‰æŒ‡å®šé¡è‰²ç¢¼çš„é ç´„\n    const color = (a.color || '').toLowerCase();\n    if (EXCLUDED_COLORS.includes(color)) {\n      console.log(`[æ‹†åˆ†å‡ºæ¯å€‹é ç´„] éæ¿¾é¡è‰²ç¢¼ ${color} çš„é ç´„ ID: ${a.id}`);\n      return false;\n    }\n    return true;\n  })\n  .map(a => {\n    const isAllDay = a.all_day === 1 || a.job_type === 'Holiday';\n    const startDT  = toDT(a.date, a.start_time, isAllDay);\n    const endDT    = toDT(a.end_date || a.date, a.end_time, isAllDay) \n                     || (startDT ? new Date(startDT.getFullYear(), startDT.getMonth(), startDT.getDate(), 23, 59, 0, 0) : null);\n\n    return {\n      ...a,\n      __date: a.date || null,\n      __user: a.user_id ?? null,\n      __startDT: startDT,\n      __endDT: endDT,\n      __district: getDistrict(a),\n      __isAllDay: isAllDay,\n    };\n  });\n\nconsole.log(`[æ‹†åˆ†å‡ºæ¯å€‹é ç´„] åŸå§‹é ç´„æ•¸: ${appts.length}, éæ¿¾å¾Œ: ${enriched.length}`);\n\n// 2) ä¾ã€Œå“¡å·¥ + æ—¥æœŸã€åˆ†çµ„\nconst groups = new Map();\nfor (const a of enriched) {\n  const key = `${a.__user ?? 'NA'}|${a.__date ?? 'NA'}`;\n  if (!groups.has(key)) groups.set(key, []);\n  groups.get(key).push(a);\n}\n\n// 3) æ¯çµ„å…§ä¾é–‹å§‹æ™‚é–“æ’åºï¼Œè¨ˆç®—å‰/å¾Œå–®è³‡è¨Š\nconst out = [];\nfor (const [, list] of groups.entries()) {\n  list.sort((x, y) => {\n    const ax = x.__startDT?.getTime() ?? 0;\n    const ay = y.__startDT?.getTime() ?? 0;\n    return ax - ay;\n  });\n\n  for (let i = 0; i < list.length; i++) {\n    const cur  = list[i];\n    const prev = i > 0 ? list[i - 1] : null;\n    const next = i < list.length - 1 ? list[i + 1] : null;\n\n    // è¨ˆç®—å‰/å¾Œå–®ç©ºæª”åˆ†é˜ï¼Œè² æ•¸ä»£è¡¨é‡ç–Šï¼Œæ­£æ•¸ç‚ºç©ºæª”\n    let prevGap = null;\n    if (prev && cur.__startDT && prev.__endDT) {\n      prevGap = Math.max(0, diffMin(cur.__startDT, prev.__endDT));\n    }\n\n    let nextGap = null;\n    if (next && cur.__endDT && next.__startDT) {\n      nextGap = Math.max(0, diffMin(next.__startDT, cur.__endDT));\n    }\n\n    // çµ„è£è¼¸å‡ºï¼Œä¿ç•™åŸæ¬„ä½ + æ–°å¢æ¬„ä½\n    out.push({\n      json: {\n        ...cur,\n\n        // å¯ç›´æ¥ç”¨åœ¨ Set ç¯€é»æˆ–å…¶ä»–ç¯€é»\n        prev_gap_minutes: prevGap,                // èˆ‡å‰å–®ç©ºæª”åˆ†é˜ï¼Œè² ç‚ºé‡ç–Š\n        next_gap_minutes: nextGap,                // èˆ‡å¾Œå–®ç©ºæª”åˆ†é˜ï¼Œè² ç‚ºé‡ç–Š\n        prev_district: prev ? getDistrict(prev) : null,  // å‰å–®åœ°å€\n        next_district: next ? getDistrict(next) : null,  // å¾Œå–®åœ°å€\n\n        // æ–¹ä¾¿é©—è­‰ï¼Œè¿½è¹¤ï¼Œå¯é¸\n        prev_id: prev?.id ?? null,\n        next_id: next?.id ?? null,\n\n        // ä¹Ÿé ç•™æª¢ç´¢ç”¨çš„å®Œæ•´æ™‚é–“å¯è®€å­—ä¸²ï¼Œå¯é¸\n        start_datetime: cur.__startDT ? cur.__startDT.toISOString() : null,\n        end_datetime:   cur.__endDT   ? cur.__endDT.toISOString()   : null,\n      }\n    });\n  }\n}\n\n// 4) å›å‚³ä¸‹æ¸¸ item\nreturn out;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18336,
        12288
      ],
      "id": "43179cde-b895-4b85-acb1-3405defcf048",
      "name": "æ‹†åˆ†å‡ºæ¯å€‹é ç´„"
    },
    {
      "parameters": {
        "assignments": {
          "assignments": [
            {
              "id": "68a5bcd6-ad5f-4bc1-9a22-55ca04aa861b",
              "name": "id",
              "value": "={{ $json.id || '' }}",
              "type": "string"
            },
            {
              "id": "bf541c9b-f45c-4365-8533-1cbdd9945f40",
              "name": "æœå‹™åœ°å€",
              "value": "={{ $json.order?.district?.label ? 'é¦™æ¸¯' + $json.order.district.label : '' }}",
              "type": "string"
            },
            {
              "id": "c9ae07a8-60ab-45f2-82b3-fb58d4927032",
              "name": "å–®é¡å‹",
              "value": "={{ $json.job_type  || '' }}",
              "type": "string"
            },
            {
              "id": "43a999aa-85ce-4b73-a550-adabc84c6a79",
              "name": "è™•ç†è·å“¡",
              "value": "={{\n  [\n    ($json.user?.name || ''),\n    ...($json.additional_workers || []).map(w => w.user?.name || '')\n  ]\n  .filter(n => n)       // ç§»é™¤ç©ºå€¼\n  .join('+')\n}}",
              "type": "string"
            },
            {
              "id": "b0f02dcb-b6ee-4790-85ef-976bfa74c236",
              "name": "æœå‹™é …ç›®",
              "value": "={{ $json.title.split('/')[0] || '' }}",
              "type": "string"
            },
            {
              "id": "b13be4f2-214a-4162-ac82-4c868aae2f01",
              "name": "æœå‹™æ—¥æœŸ",
              "value": "={{ $json.date  || '' }}",
              "type": "string"
            },
            {
              "id": "79db96b2-3973-4c01-b824-8b7ed207c35d",
              "name": "é–‹å§‹æ™‚é–“",
              "value": "={{ $json.start_time  || '' }}",
              "type": "string"
            },
            {
              "id": "313842f2-90f5-44aa-a3d2-d262a4cef97d",
              "name": "çµæŸæ—¥æœŸ",
              "value": "={{ $json.end_date  || '' }}",
              "type": "string"
            },
            {
              "id": "57057510-3c9b-4eef-aa44-224ebd4b42a3",
              "name": "çµæŸæ™‚é–“",
              "value": "={{ $json.end_time  || '' }}",
              "type": "string"
            },
            {
              "id": "144d664d-e850-4fd9-bc33-dc5673ad842a",
              "name": "å‰µå»ºæ—¥æœŸ",
              "value": "={{ DateTime.fromISO($json.created_at  || '').toFormat('yyyy-MM-dd') }}",
              "type": "string"
            },
            {
              "id": "e9a9388f-ae0f-404c-917c-d09f6f4c5a9d",
              "name": "å‰µå»ºæ™‚é–“",
              "value": "={{ DateTime.fromISO($json.created_at  || '').toFormat('HH:mm') }}",
              "type": "string"
            },
            {
              "id": "19a35dd9-1bb2-42a2-9d7a-2bc9bf7e2ac9",
              "name": "å‰ä¸€å–®çš„åœ°å€",
              "value": "={{ $json.prev_district }}",
              "type": "string"
            },
            {
              "id": "a37b6041-80e3-4be6-a203-75a87bcf6603",
              "name": "å¾Œä¸€å–®çš„åœ°å€",
              "value": "={{ $json.next_district }}",
              "type": "string"
            },
            {
              "id": "e6522adb-725a-433b-b60d-593eef0872f0",
              "name": "èˆ‡å‰ä¸€å–®ç©ºæª”æ™‚é–“",
              "value": "={{ $json.prev_gap_minutes != null ? $json.prev_gap_minutes + ' åˆ†é˜' : null }}",
              "type": "string"
            },
            {
              "id": "43f31ca8-2c29-4871-b65d-1afed1d98c4c",
              "name": "èˆ‡å¾Œä¸€å–®ç©ºæª”æ™‚é–“",
              "value": "={{ $json.next_gap_minutes != null ? $json.next_gap_minutes + ' åˆ†é˜' : null }}",
              "type": "string"
            },
            {
              "id": "64e5d749-54ca-4e12-8ad0-9035d80c2150",
              "name": "å“ç‰Œ",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å“ç‰Œ'] }}",
              "type": "string"
            },
            {
              "id": "0bd4e308-e30a-4253-9582-2997161e64df",
              "name": "æœå‹™",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['æœå‹™'] }}",
              "type": "string"
            },
            {
              "id": "770f93aa-5a2b-4d13-a86e-827ecc36198c",
              "name": "åœ°å€",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['åœ°å€'] }}",
              "type": "string"
            },
            {
              "id": "9f56acee-5d91-4663-8ebc-abe91b237e79",
              "name": "å–®ä½å°ºæ•¸ (å¹³æ–¹å°º)",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å–®ä½å°ºæ•¸ (å¹³æ–¹å°º)'] }}",
              "type": "number"
            },
            {
              "id": "25d9c339-1cea-4b8d-be14-f0ddfceeab8a",
              "name": "å•é¡Œåš´é‡ç¨‹åº¦(1-5ç´š)",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å•é¡Œåš´é‡ç¨‹åº¦(1-5ç´š)'] }}",
              "type": "number"
            },
            {
              "id": "064dc33e-ad7b-49db-8be7-375a0d7a86c7",
              "name": "é ä¼°æœå‹™æ™‚é–“(åˆ†é˜)",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['é ä¼°æœå‹™æ™‚é–“(åˆ†é˜)'] }}",
              "type": "number"
            },
            {
              "id": "56ad3f8f-1979-4554-a0c4-291703ca99d4",
              "name": "å›è¨ªä¸­é–“ç©ºæª”(å°æ™‚)",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å›è¨ªä¸­é–“ç©ºæª”(å°æ™‚)'] ? Number($('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å›è¨ªä¸­é–“ç©ºæª”(å°æ™‚)']) : 0 }}",
              "type": "number"
            },
            {
              "id": "fd7d3b73-a628-498d-8fb9-a7969da43035",
              "name": "å›è¨ªåœç•™æ™‚é•·(åˆ†é˜)",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å›è¨ªåœç•™æ™‚é•·(åˆ†é˜)'] ? Number($('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å›è¨ªåœç•™æ™‚é•·(åˆ†é˜)']) : 0 }}",
              "type": "number"
            },
            {
              "id": "6b647f7c-025b-4b30-9afe-adb0cd2467fa",
              "name": "å‚™è¨»",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['å‚™è¨»'] }}",
              "type": "string"
            },
            {
              "id": "78143fe0-e233-4197-95b2-1dc28c36ad35",
              "name": "æäº¤æ—¥æœŸ",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['æäº¤æ—¥æœŸ'] }}",
              "type": "string"
            },
            {
              "id": "b7e8ac31-63c1-4028-b8f1-9da2cd80b216",
              "name": "æäº¤æ™‚é–“",
              "value": "={{ $('æŠ½å‡ºå¿…è¦å­—æ®µ').item.json['æäº¤æ™‚é–“'] }}",
              "type": "string"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.set",
      "typeVersion": 3.4,
      "position": [
        18528,
        12032
      ],
      "id": "bdb64f8d-e8ce-4fa5-84b3-c5d4b6d4963e",
      "name": "CRM-æŠ½å‡ºå¿…è¦å­—æ®µ",
      "options": {
        "keepOnlySet": true
      }
    },
    {
      "parameters": {
        "url": "https://pestskillerhk.app/api/appointments/timetable",
        "authentication": "genericCredentialType",
        "genericAuthType": "httpBearerAuth",
        "sendQuery": true,
        "queryParameters": {
          "parameters": [
            {
              "name": "filters[view]",
              "value": "dayGridMonth"
            },
            {
              "name": "filters[start]",
              "value": "={{ DateTime.fromISO($json['æäº¤æ—¥æœŸ']).plus({ days: 2 }).toFormat('yyyy-MM-dd') }}"
            },
            {
              "name": "filters[end]",
              "value": "={{ DateTime.fromISO($json['æäº¤æ—¥æœŸ']).plus({ days: 13 }).toFormat('yyyy-MM-dd') }}"
            }
          ]
        },
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Accept",
              "value": "application/json"
            },
            {
              "name": "Content-Type",
              "value": "application/json"
            }
          ]
        },
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        18112,
        12288
      ],
      "id": "4281ac5a-2f0f-4f90-8bd3-970b9796eec4",
      "name": "ç²å–æœªä¾†7D CRMæ’ç¨‹",
      "credentials": {
        "httpBearerAuth": {
          "id": "R3bd7I4KesETUTAr",
          "name": "Pest Killer CRM"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "/**\n * Simplified AI Data Preparation with Staff Config\n * âœ… UPDATED: Added fuzzy column matching for home_district\n *\n * Purpose: Parse appointments, build staff config, calculate free slots\n * Filtering is done in later stages\n */\n\n// ========= Helper Functions =========\nconst Helpers = {\n  toMin: (timeStr) => {\n    if (!timeStr) return null;\n    const [h, m] = String(timeStr).split(':').map(Number);\n    return Number.isFinite(h) && Number.isFinite(m) ? h * 60 + m : null;\n  },\n\n  fromMin: (minutes) => {\n    if (minutes == null || !Number.isFinite(minutes)) return null;\n    const h = String(Math.floor(minutes / 60)).padStart(2, '0');\n    const m = String(minutes % 60).padStart(2, '0');\n    return `${h}:${m}`;\n  },\n\n  addDays: (dateStr, daysToAdd) => {\n    if (!dateStr) return null;\n    try {\n      const [y, m, d] = String(dateStr).split('-').map(Number);\n      const dt = new Date(Date.UTC(y, m - 1, d));\n      if (isNaN(dt.getTime())) return null;\n      dt.setUTCDate(dt.getUTCDate() + daysToAdd);\n      return dt.toISOString().split('T')[0];\n    } catch (e) { return null; }\n  },\n\n  todayHK: () => {\n    const now = new Date();\n    const hk = new Date(now.getTime() + 8 * 60 * 60000 - now.getTimezoneOffset() * 60000);\n    return hk.toISOString().split('T')[0];\n  },\n\n  extractNumber: (str) => {\n    if (str == null) return null;\n    const num = Number(String(str).replace(/[^\\d.-]/g, \"\"));\n    return Number.isFinite(num) ? num : null;\n  }\n};\n\n// ========= Fuzzy Find Home District =========\n// âœ… NEW: Try multiple possible column names for home district\nfunction findHomeDistrict(row) {\n  if (!row || typeof row !== 'object') return null;\n\n  // Priority 1: Check _parsed.home_district (from æ•´ç†Googleè·å“¡è³‡æ–™)\n  if (row._parsed && row._parsed.home_district) {\n    return row._parsed.home_district;\n  }\n\n  // Priority 2: Check top-level home_district\n  if (row.home_district && String(row.home_district).trim()) {\n    return String(row.home_district).trim();\n  }\n\n  // Priority 3: Exact column names\n  const exactKeys = ['å±…ä½åœ°', 'å±…ä½åœ°å€', 'ä½å€', 'åœ°å€', 'homeDistrict', 'address'];\n  for (const key of exactKeys) {\n    const val = row[key];\n    if (val !== undefined && val !== null && String(val).trim()) {\n      return String(val).trim();\n    }\n  }\n\n  // Priority 4: Fuzzy match - columns containing these keywords\n  const fuzzyPatterns = ['å±…ä½', 'ä½å€'];\n  for (const key of Object.keys(row)) {\n    for (const pattern of fuzzyPatterns) {\n      if (key.includes(pattern)) {\n        const val = row[key];\n        if (val !== undefined && val !== null && String(val).trim()) {\n          return String(val).trim();\n        }\n      }\n    }\n  }\n\n  return null;\n}\n\n// ========= Build Staff Config (Work Hours + Home District) =========\nfunction buildStaffConfig(staffMeta, staffSheet, googleSheetData) {\n  const result = {};\n\n  const processRows = (rows) => {\n    console.log(`[buildStaffConfig] Processing ${rows.length} rows`);\n\n    // Debug: Show column names from first row\n    if (rows.length > 0) {\n      const firstRow = rows[0];\n      const keys = Object.keys(firstRow);\n      console.log(`[buildStaffConfig] ğŸ“‹ Available columns:`, keys.slice(0, 15).join(', '));\n    }\n\n    for (const row of rows) {\n      if (!row || typeof row !== 'object') continue;\n      const name = row[\"è·å“¡\"] || row[\"name\"] || row[\"Name\"];\n      if (!name) continue;\n\n      const cleanName = String(name).trim();\n\n      let workStart, workEnd;\n      if (row._parsed && row._parsed.work_start && row._parsed.work_end) {\n        workStart = row._parsed.work_start;\n        workEnd = row._parsed.work_end;\n      } else {\n        const start = (row[\"é–‹å·¥æ™‚æ®µ\"] || row[\"work_start\"] || \"\").toString().trim();\n        const end = (row[\"æ”¶å·¥æ™‚æ®µ\"] || row[\"work_end\"] || \"\").toString().trim();\n        workStart = start || \"09:00\";\n        workEnd = end || \"18:00\";\n      }\n\n      // âœ… Use fuzzy find for home district\n      const homeDistrict = findHomeDistrict(row);\n\n      result[cleanName] = {\n        work_start: workStart,\n        work_end: workEnd,\n        home_district: homeDistrict,\n        buffer_min: Number(row[\"äº¤é€šç·©è¡(åˆ†é˜)\"] || row[\"buffer_min\"]) || null\n      };\n\n      // Debug log for first few staff\n      if (Object.keys(result).length <= 3) {\n        console.log(`[buildStaffConfig] Staff \"${cleanName}\": home_district = \"${homeDistrict || '(null)'}\"`);\n      }\n    }\n  };\n\n  // Google Sheets has highest priority\n  if (Array.isArray(staffSheet) && staffSheet.length) {\n    console.log(`[buildStaffConfig] Using staffSheet (${staffSheet.length} rows)`);\n    processRows(staffSheet);\n  } else if (Array.isArray(googleSheetData) && googleSheetData.length) {\n    console.log(`[buildStaffConfig] Using googleSheetData (${googleSheetData.length} rows)`);\n    processRows(googleSheetData);\n  } else {\n    console.log(`[buildStaffConfig] âš ï¸ No staffSheet or googleSheetData available`);\n  }\n\n  // Supplement with staffMeta\n  if (Array.isArray(staffMeta) && staffMeta.length) {\n    for (const s of staffMeta) {\n      if (s && s.name) {\n        const cleanName = String(s.name).trim();\n        if (!result[cleanName]) {\n          result[cleanName] = {\n            work_start: s.work_start || \"09:00\",\n            work_end: s.work_end || \"18:00\",\n            home_district: s.home_district || null,\n            buffer_min: Number(s.buffer_min) || null\n          };\n        } else if (!result[cleanName].home_district && s.home_district) {\n          // âœ… Fill in missing home_district from staffMeta\n          result[cleanName].home_district = s.home_district;\n        }\n      }\n    }\n  }\n\n  return result;\n}\n\n// ========= Parse Appointments =========\nfunction parseAppointments(raw) {\n  const machineData = [];\n  const holidayIndex = {};\n\n  for (const item of raw) {\n    if (!item || typeof item !== 'object') continue;\n\n    // Holiday tracking\n    const staffStr = item[\"è™•ç†è·å“¡\"] || '';\n    const jobType = (item[\"å–®é¡å‹\"] || '').toLowerCase();\n    if (staffStr && (jobType === 'holiday' || /å‡|holiday/i.test(item.title || ''))) {\n      const start = item.date || item[\"æœå‹™æ—¥æœŸ\"];\n      const end = item[\"çµæŸæ—¥æœŸ\"] || start;\n      if (start) {\n        const staffNames = staffStr.split(/[+ï¼‹]/).map(s => s.trim()).filter(Boolean);\n        const dates = [];\n        let curr = start;\n        while (curr && dates.length < 365) {\n          dates.push(curr);\n          if (curr === end) break;\n          curr = Helpers.addDays(curr, 1);\n        }\n        for (const staff of staffNames) {\n          if (!holidayIndex[staff]) holidayIndex[staff] = {};\n          for (const d of dates) holidayIndex[staff][d] = true;\n        }\n      }\n    }\n\n    // Machine data\n    const sDate = item[\"æœå‹™æ—¥æœŸ\"];\n    const sTime = item[\"é–‹å§‹æ™‚é–“\"];\n    const eDate = item[\"çµæŸæ—¥æœŸ\"];\n    const eTime = item[\"çµæŸæ™‚é–“\"];\n\n    machineData.push({\n      id: item.id ? Number(item.id) : null,\n      service_district: item[\"æœå‹™åœ°å€\"] || null,\n      job_type: item[\"å–®é¡å‹\"] || null,\n      staff: item[\"è™•ç†è·å“¡\"] || null,\n      service: item[\"æœå‹™é …ç›®\"] || null,\n      start_at: (sDate && sTime) ? `${sDate}T${sTime}:00+08:00` : null,\n      end_at: (eDate && eTime) ? `${eDate}T${eTime}:00+08:00` : null,\n      prev: {\n        district: item[\"å‰ä¸€å–®çš„åœ°å€\"] || null,\n        gap_minutes: Helpers.extractNumber(item[\"èˆ‡å‰ä¸€å–®ç©ºæª”æ™‚é–“\"]),\n        drive_minutes: Helpers.extractNumber(item[\"èˆ‡å‰ä¸€å–®åœ°å€è¡Œè»Šæ™‚é–“\"])\n      },\n      next: {\n        district: item[\"å¾Œä¸€å–®çš„åœ°å€\"] || null,\n        gap_minutes: Helpers.extractNumber(item[\"èˆ‡å¾Œä¸€å–®ç©ºæª”æ™‚é–“\"]),\n        drive_minutes: Helpers.extractNumber(item[\"èˆ‡å¾Œä¸€å–®åœ°å€è¡Œè»Šæ™‚é–“\"])\n      },\n      drive_to_new_request_minutes: Helpers.extractNumber(item[\"èˆ‡æ–°é ç´„è¡Œè»Šæ™‚é–“\"]),\n      revisit: {\n        required: Boolean(item[\"æ˜¯å¦éœ€è¦å›è¨ª\"]),\n        mid_gap: item[\"åˆè¨ªèˆ‡å›è¨ªä¸­é–“ç©ºæª”æ™‚é–“\"] || null,\n        revisit_slot: item[\"å›è¨ªæ™‚é–“åŠåœç•™æ™‚é•·\"] || null\n      }\n    });\n  }\n\n  return { machineData, holidayIndex };\n}\n\n// ========= Build Schedule Index =========\nfunction buildScheduleIndex(machineData) {\n  const indexed = {};\n  const staffSet = new Set();\n\n  for (const apt of machineData) {\n    if (!apt.staff || !apt.start_at) continue;\n\n    const date = apt.start_at.slice(0, 10);\n    const start = apt.start_at.slice(11, 16);\n    const end = apt.end_at ? apt.end_at.slice(11, 16) : null;\n\n    const staffNames = apt.staff.split(/[+ï¼‹]/).map(s => s.trim()).filter(Boolean);\n\n    for (const staff of staffNames) {\n      if (!staff) continue;\n      staffSet.add(staff);\n\n      if (!indexed[staff]) indexed[staff] = {};\n      if (!indexed[staff][date]) indexed[staff][date] = [];\n\n      indexed[staff][date].push({\n        id: apt.id,\n        service: apt.service,\n        district: apt.service_district,\n        start,\n        end\n      });\n    }\n  }\n\n  return { indexed, staffList: Array.from(staffSet) };\n}\n\n// ========= Calculate Free Slots =========\nfunction calculateFreeSlots(staffList, indexed, holidayIndex, staffCfg, days11, defaultBuffer) {\n  return staffList.map(staff => {\n    const config = staffCfg[staff] || {};\n    const workStart = config.work_start || \"09:00\";\n    const workEnd = config.work_end || \"18:00\";\n    const workStartMin = Helpers.toMin(workStart);\n    const workEndMin = Helpers.toMin(workEnd);\n    const bufferMin = Number(config.buffer_min) || defaultBuffer;\n\n    if (workStartMin == null || workEndMin == null || workStartMin >= workEndMin) {\n      return { staff, days: [] };\n    }\n\n    const days = days11.map(date => {\n      // Check Holiday\n      if (holidayIndex[staff]?.[date]) {\n        return {\n          date,\n          work_start: null,\n          work_end: null,\n          holiday: true,\n          appointments: [],\n          free_slots: []\n        };\n      }\n\n      const appointments = indexed[staff]?.[date] || [];\n\n      // Build blocked ranges\n      const blocks = [];\n      for (const apt of appointments) {\n        const s = Helpers.toMin(apt.start);\n        const e = Helpers.toMin(apt.end);\n        if (s != null && e != null) {\n          const adjS = Math.max(s, workStartMin);\n          const adjE = Math.min(e, workEndMin);\n          if (adjS < adjE) {\n            blocks.push({\n              s: Math.max(adjS - bufferMin, workStartMin),\n              e: Math.min(adjE + bufferMin, workEndMin)\n            });\n          }\n        }\n      }\n\n      blocks.sort((a, b) => a.s - b.s);\n\n      // Merge blocks\n      const merged = [];\n      for (const b of blocks) {\n        if (!merged.length || b.s > merged[merged.length - 1].e) {\n          merged.push(b);\n        } else {\n          merged[merged.length - 1].e = Math.max(merged[merged.length - 1].e, b.e);\n        }\n      }\n\n      // Calculate free slots\n      const freeSlots = [];\n      let curr = workStartMin;\n      for (const m of merged) {\n        if (m.s > curr) {\n          freeSlots.push({\n            start: Helpers.fromMin(curr),\n            end: Helpers.fromMin(m.s),\n            minutes: m.s - curr\n          });\n        }\n        curr = Math.max(curr, m.e);\n      }\n      if (curr < workEndMin) {\n        freeSlots.push({\n          start: Helpers.fromMin(curr),\n          end: Helpers.fromMin(workEndMin),\n          minutes: workEndMin - curr\n        });\n      }\n\n      // Calculate booked minutes\n      let booked = 0;\n      for (const apt of appointments) {\n        const s = Helpers.toMin(apt.start);\n        const e = Helpers.toMin(apt.end);\n        if (s != null && e != null) {\n          booked += Math.max(0, Math.min(e, workEndMin) - Math.max(s, workStartMin));\n        }\n      }\n\n      let totalFree = 0;\n      let maxFree = 0;\n      for (const slot of freeSlots) {\n        totalFree += slot.minutes;\n        if (slot.minutes > maxFree) maxFree = slot.minutes;\n      }\n\n      return {\n        date,\n        work_start: workStart,\n        work_end: workEnd,\n        holiday: false,\n        appointments,\n        free_slots: freeSlots,\n        booked_minutes: booked,\n        total_free_minutes: totalFree,\n        max_contiguous_free_minutes: maxFree\n      };\n    });\n\n    return { staff, days };\n  });\n}\n\n// ========= Main Process =========\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  if (!item || !item.json) continue;\n\n  const json = item.json;\n  const raw = Array.isArray(json.data) ? json.data : [];\n\n  // Build staff config\n  const sheetData = (Array.isArray(json.staffSheet) && json.staffSheet.length)\n    ? json.staffSheet\n    : [];\n  const staffCfg = buildStaffConfig(json.staffMeta, json.staffSheet, sheetData);\n\n  // Parse appointments\n  const { machineData, holidayIndex } = parseAppointments(raw);\n\n  // Build schedule index\n  const { indexed, staffList } = buildScheduleIndex(machineData);\n\n  // Calculate date window\n  // ALWAYS use today + 2 calendar days (not submission date)\n  // Example: Today is Dec 20, 2025 -> Find slots starting Dec 22, 2025\n  const today = Helpers.todayHK();\n  const startDate = Helpers.addDays(today, 2);\n  console.log(`[ğŸ“‹ AIæº–å‚™] æ—¥æœŸè¨ˆç®—: ä»Šå¤©=${today}, é–‹å§‹æ—¥æœŸ=${startDate} (ä»Šå¤©+2æ—¥æ›†å¤©)`);\n\n  const days11 = [];\n  let curr = startDate;\n  for (let i = 0; i < 11; i++) {\n    days11.push(curr);\n    curr = Helpers.addDays(curr, 1);\n  }\n  const windowEnd = days11[days11.length - 1];\n\n  // Calculate free slots with staff-specific work hours\n  const defaultBuffer = Number(json[\"äº¤é€šç·©è¡(åˆ†é˜)\"]) || 30;\n  const freeSlotsCalendar = calculateFreeSlots(\n    staffList,\n    indexed,\n    holidayIndex,\n    staffCfg,\n    days11,\n    defaultBuffer\n  );\n\n  console.log(`[ğŸ“‹ AIæº–å‚™] è™•ç†å®Œæˆ: ${staffList.length} ä½è·å“¡, ${days11.length} å¤©`);\n  console.log(`[ğŸ“‹ AIæº–å‚™] è·å“¡é…ç½®æ•¸: ${Object.keys(staffCfg).length}`);\n\n  // Debug: Show staffCfg home_district values\n  const staffWithAddress = Object.entries(staffCfg).filter(([name, cfg]) => cfg.home_district).map(([name, cfg]) => `${name}: ${cfg.home_district}`);\n  console.log(`[ğŸ“‹ AIæº–å‚™] æœ‰ä½å€çš„è·å“¡: ${staffWithAddress.length}/${Object.keys(staffCfg).length}`);\n  if (staffWithAddress.length > 0) {\n    console.log(`[ğŸ“‹ AIæº–å‚™] ä½å€åˆ—è¡¨:`, staffWithAddress.slice(0, 5).join(', '));\n  } else {\n    console.log(`[ğŸ“‹ AIæº–å‚™] âš ï¸ æ²’æœ‰è·å“¡æœ‰ä½å€æ•¸æ“šï¼è«‹æª¢æŸ¥ Google Sheets çš„ã€Œå±…ä½åœ°ã€æ¬„ä½`);\n    // âœ… NEW: Show what columns ARE available in staffSheet\n    if (json.staffSheet && json.staffSheet.length > 0) {\n      const sampleRow = json.staffSheet[0];\n      console.log(`[ğŸ“‹ AIæº–å‚™] ğŸ“‹ staffSheet å¯ç”¨æ¬„ä½:`, Object.keys(sampleRow).slice(0, 15).join(', '));\n    }\n  }\n\n  results.push({\n    json: {\n      ...json,\n      machineData,\n      freeSlotsCalendar,\n      holidayIndex,\n      staffCfg,\n      staffList,\n      windowStart: startDate,\n      windowEnd,\n      serviceDistrict: json.district || json['åœ°å€'] || 'é¦™æ¸¯'\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18368,
        12848
      ],
      "id": "36e7ecae-6f11-4af6-9b3e-a341e5e40964",
      "name": "æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½",
      "alwaysOutputData": false
    },
    {
      "parameters": {
        "promptType": "define",
        "text": "={{ $json.user_prompt_debug }}",
        "options": {
          "systemMessage": "={{ $json.system_prompt }}"
        }
      },
      "type": "@n8n/n8n-nodes-langchain.agent",
      "typeVersion": 2,
      "position": [
        19440,
        13008
      ],
      "id": "10471898-fad4-4389-8917-c2b9a052f5d3",
      "name": "AI Agent"
    },
    {
      "parameters": {
        "jsCode": "// @ts-ignore - items is provided by n8n runtime\nconst GAP_MINUTES = 330;\nconst STAY_MINUTES = 60;\n\n// è£ä¿®å¾Œæ¸…æ½”é¡æœå‹™ï¼ˆå¿…å®šéœ€è¦å›è¨ªï¼‰\nconst CLEANING_PATTERNS = [\n  /è£ä¿®å¾Œæ¸…æ½”|è£æ¸…/i,\n  /å…¥ä¼™å‰æ¸…æ½”|å…¥æ¸…/i,\n  /å‰å±‹æ¸…æ½”|å‰æ¸…/i,\n  /æ·±å±¤æ¸…æ½”|æ·±æ¸…/i,\n];\n\n// é™¤ç”²é†›æœå‹™æ¨¡å¼\nconst FORMALDEHYDE_PATTERN = /é™¤ç”²é†›|ç”²A|ç”²B|ç”²C/i;\n\nfunction needsRevisit(name = '') {\n  const clean = name.replace(/[^ä¸€-é¾¥A-Za-z0-9+ï¼‹]/g, '');\n  \n  // æª¢æŸ¥æ˜¯å¦ç‚ºæ¸…æ½”é¡æœå‹™ï¼ˆå¿…å®šéœ€è¦å›è¨ªï¼‰\n  const isCleaning = CLEANING_PATTERNS.some(pattern => pattern.test(clean));\n  if (isCleaning) {\n    return true;\n  }\n  \n  // æª¢æŸ¥æ˜¯å¦åŒ…å«é™¤ç”²é†›æœå‹™\n  const hasFormaldehyde = FORMALDEHYDE_PATTERN.test(name);\n  if (hasFormaldehyde) {\n    // æª¢æŸ¥æ˜¯å¦ç‚ºçµ„åˆæœå‹™ï¼ˆå¦‚ï¼šè£æ¸…+ç”²Cï¼‰\n    const isCombined = /[+ï¼‹]/.test(name) || CLEANING_PATTERNS.some(pattern => pattern.test(name));\n    \n    if (isCombined) {\n      // çµ„åˆæœå‹™ï¼šé™¤ç”²é†›åœ¨å›è¨ªæ™‚é€²è¡Œï¼Œéœ€è¦å›è¨ª\n      console.log(`[å›è¨ªåˆ¤æ–·] ${name} - çµ„åˆæœå‹™ï¼Œéœ€è¦å›è¨ªï¼ˆé™¤ç”²é†›åœ¨å›è¨ªæ™‚é€²è¡Œï¼‰`);\n      return true;\n    } else {\n      // å–®é …é™¤ç”²é†›æœå‹™ï¼šç›´æ¥åœ¨åˆè¨ªé€²è¡Œï¼Œä¸éœ€è¦å›è¨ª\n      console.log(`[å›è¨ªåˆ¤æ–·] ${name} - å–®é …é™¤ç”²é†›æœå‹™ï¼Œä¸éœ€è¦å›è¨ª`);\n      return false;\n    }\n  }\n  \n  return false;\n}\n\nfunction toDate(dateStr, timeStr) {\n  if (!dateStr || !timeStr) {\n    return null;\n  }\n  const [y, m, d] = dateStr.split('-').map(Number);\n  const [h, min] = timeStr.split(':').map(Number);\n  if (!y || !m || !d || Number.isNaN(h) || Number.isNaN(min)) {\n    return null;\n  }\n  return new Date(y, m - 1, d, h, min, 0, 0);\n}\n\nfunction formatHM(date) {\n  return `${String(date.getHours()).padStart(2, '0')}:${String(date.getMinutes()).padStart(2, '0')}`;\n}\n\nfunction addMinutes(date, minutes) {\n  return new Date(date.getTime() + minutes * 60000);\n}\n\n// @ts-ignore - items is provided by n8n runtime\nconst inputItems = (typeof $input !== 'undefined' && $input.all) ? $input.all() : (typeof items !== 'undefined' ? items : []);\nlet revisitCount = 0;\nconst results = inputItems.map(item => {\n  const record = { ...item.json };\n  record['æ˜¯å¦éœ€è¦å›è¨ª'] = false;\n  record['åˆè¨ªèˆ‡å›è¨ªä¸­é–“ç©ºæª”æ™‚é–“'] = '';\n  record['å›è¨ªæ™‚é–“åŠåœç•™æ™‚é•·'] = '';\n\n  const isValidOrder = ['New Order', 'Regular Order'].includes(record['å–®é¡å‹']);\n  if (isValidOrder && needsRevisit(record['æœå‹™é …ç›®'])) {\n    const start = toDate(record['æœå‹™æ—¥æœŸ'], record['é–‹å§‹æ™‚é–“']);\n    const end = toDate(record['æœå‹™æ—¥æœŸ'], record['çµæŸæ™‚é–“']);\n    if (start && end && end > start) {\n      const gapCandidate = addMinutes(end, GAP_MINUTES);\n      const fourPm = new Date(end.getFullYear(), end.getMonth(), end.getDate(), 16, 0, 0, 0);\n      const revisitStart = gapCandidate < fourPm ? gapCandidate : fourPm;\n      const revisitEnd = addMinutes(revisitStart, STAY_MINUTES);\n      record['æ˜¯å¦éœ€è¦å›è¨ª'] = true;\n      record['åˆè¨ªèˆ‡å›è¨ªä¸­é–“ç©ºæª”æ™‚é–“'] = `${formatHM(end)}â€“${formatHM(revisitStart)}`;\n      record['å›è¨ªæ™‚é–“åŠåœç•™æ™‚é•·'] = `${formatHM(revisitStart)}â€“${formatHM(revisitEnd)} (${STAY_MINUTES} åˆ†)`;\n      revisitCount += 1;\n    }\n  }\n\n  return { json: record };\n});\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17488,
        12736
      ],
      "id": "29b6be5b-2637-4717-8a0c-082c67c03030",
      "name": "åˆ¤æ–·å›è¨ªé ç´„",
      "notesInFlow": "åœ¨ Function Item å…§åˆ¤æ–·æ˜¯å¦å±¬æ–¼éœ€è¦å›è¨ªçš„æœå‹™ä¸¦è¨ˆç®—å›è¨ªæ™‚æ®µï¼Œé¿å… Code ç¯€é»é‡è¤‡è™•ç†ã€‚"
    },
    {
      "parameters": {
        "jsCode": "// Fixed n8n node code for Google Maps Distance Matrix API\n// Issues fixed:\n// 1. Changed 'uri' to 'url' (n8n httpRequest uses 'url')\n// 2. Added comprehensive error handling\n// 3. Added validation for empty destinations\n// 4. Added response structure validation\n// 5. Added better logging for debugging\n\nconst API_URL = 'https://maps.googleapis.com/maps/api/distancematrix/json';\nconst API_KEY = 'AIzaSyCujmDrdlHgPEaKxtn8CbpBNPKwhXIDUKs'; // TODO: Move to n8n credentials\nconst MAX_DEST = 25;\n\n// Validate input items\nconst inputItems = (typeof $input !== 'undefined' && $input.all) ? $input.all() : (typeof items !== 'undefined' ? items : []);\nif (!inputItems || !Array.isArray(inputItems) || inputItems.length === 0) {\n  console.log('No items to process');\n  return inputItems || [];\n}\n\nconst requestArea = items[0]?.json['åœ°å€'] ?? items[0]?.json['æ–°é ç´„åœ°å€'] ?? null;\n\nif (!requestArea) {\n  console.log('No request area found, skipping distance calculation');\n  return items;\n}\n\nconst combos = [];\nconst seen = new Set();\n\nfunction pushCombo(origin, dest) {\n  if (!origin || !dest) {\n    return;\n  }\n  const key = `${origin}::${dest}`;\n  if (seen.has(key)) {\n    return;\n  }\n  seen.add(key);\n  combos.push({ origin, dest });\n}\n\n// Collect all origin-destination pairs\ninputItems.forEach((item) => {\n  const serviceArea = item.json['æœå‹™åœ°å€'];\n  pushCombo(requestArea, serviceArea);\n  \n  const prevDistrict = item.json['å‰ä¸€å–®çš„åœ°å€'];\n  const nextDistrict = item.json['å¾Œä¸€å–®çš„åœ°å€'];\n  \n  if (serviceArea && prevDistrict) {\n    pushCombo(serviceArea, prevDistrict);\n  }\n  if (serviceArea && nextDistrict) {\n    pushCombo(serviceArea, nextDistrict);\n  }\n});\n\nif (!combos.length) {\n  console.log('No distance combinations to calculate');\n  return items;\n}\n\n// Group by origin for batch requests\nconst groups = combos.reduce((acc, combo) => {\n  if (!acc.has(combo.origin)) {\n    acc.set(combo.origin, []);\n  }\n  acc.get(combo.origin).push(combo);\n  return acc;\n}, new Map());\n\nconst requests = [];\n\n// Build batch requests\nfor (const [origin, rows] of groups.entries()) {\n  for (let i = 0; i < rows.length; i += MAX_DEST) {\n    const chunk = rows.slice(i, i + MAX_DEST);\n    const destinations = chunk.map(c => c.dest).filter(d => d).join('|');\n    \n    // Validate destinations string\n    if (!destinations || destinations.trim() === '') {\n      console.warn(`Skipping request with empty destinations for origin: ${origin}`);\n      continue;\n    }\n    \n    const options = {\n      method: 'GET',\n      url: API_URL, // FIXED: Changed from 'uri' to 'url'\n      qs: {\n        origins: origin,\n        destinations: destinations,\n        key: API_KEY,\n        mode: 'driving',\n        language: 'zh-HK',\n        region: 'HK'\n      },\n      json: true\n    };\n    \n    // Wrap request in error handling\n    requests.push(\n      this.helpers.httpRequest(options)\n        .then(response => {\n          // Validate response structure\n          if (!response || !response.rows || !Array.isArray(response.rows) || response.rows.length === 0) {\n            console.error('Invalid response structure:', response);\n            return { response: null, chunk, error: 'Invalid response structure' };\n          }\n          \n          if (response.status !== 'OK' && response.error_message) {\n            console.error('API Error:', response.error_message);\n            return { response: null, chunk, error: response.error_message };\n          }\n          \n          return { response, chunk };\n        })\n        .catch(error => {\n          console.error(`Error fetching distance for origin ${origin}:`, error.message || error);\n          return { response: null, chunk, error: error.message || 'Unknown error' };\n        })\n    );\n  }\n}\n\n// Wait for all requests to complete\nconst responses = await Promise.all(requests);\n\nconst durationMap = new Map();\n\nfunction mapKey(origin, dest) {\n  return `${origin}::${dest}`;\n}\n\n// Process responses\nresponses.forEach(({ response, chunk, error }) => {\n  if (error) {\n    console.warn(`Skipping chunk due to error: ${error}`);\n    return;\n  }\n  \n  if (!response || !response.rows || !Array.isArray(response.rows) || response.rows.length === 0) {\n    console.warn('Skipping invalid response');\n    return;\n  }\n  \n  const elements = response.rows[0]?.elements || [];\n  \n  if (elements.length !== chunk.length) {\n    console.warn(`Mismatch: expected ${chunk.length} elements, got ${elements.length}`);\n  }\n  \n  chunk.forEach((combo, idx) => {\n    const element = elements[idx];\n    \n    if (!element) {\n      console.warn(`Missing element at index ${idx} for combo ${mapKey(combo.origin, combo.dest)}`);\n      return;\n    }\n    \n    if (element.status === 'OK' && element.duration) {\n      durationMap.set(mapKey(combo.origin, combo.dest), {\n        text: element.duration.text,\n        value: element.duration.value\n      });\n    } else {\n      console.warn(`Element status not OK for ${mapKey(combo.origin, combo.dest)}:`, element.status);\n    }\n  });\n});\n\n// Update items with duration data\ninputItems.forEach((item) => {\n  const serviceArea = item.json['æœå‹™åœ°å€'];\n  const prevDistrict = item.json['å‰ä¸€å–®çš„åœ°å€'];\n  const nextDistrict = item.json['å¾Œä¸€å–®çš„åœ°å€'];\n  \n  if (requestArea && serviceArea) {\n    const duration = durationMap.get(mapKey(requestArea, serviceArea));\n    if (duration) {\n      item.json['èˆ‡æ–°é ç´„è¡Œè»Šæ™‚é–“'] = `${duration.text}é˜`;\n      item.json['drive_to_new_request_minutes'] = Math.round(duration.value / 60);\n    }\n  }\n  \n  if (serviceArea && prevDistrict) {\n    const duration = durationMap.get(mapKey(serviceArea, prevDistrict));\n    if (duration) {\n      item.json['èˆ‡å‰ä¸€å–®åœ°å€è¡Œè»Šæ™‚é–“'] = duration.text;\n    }\n  }\n  \n  if (serviceArea && nextDistrict) {\n    const duration = durationMap.get(mapKey(serviceArea, nextDistrict));\n    if (duration) {\n      item.json['èˆ‡å¾Œä¸€å–®åœ°å€è¡Œè»Šæ™‚é–“'] = duration.text;\n    }\n  }\n});\n\nreturn items;\n\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18608,
        12256
      ],
      "id": "7aeece9c-6409-4824-be21-eef9b09e5b34",
      "name": "è·é›¢çŸ©é™£æ‰¹æ¬¡",
      "notesInFlow": "ä¸€æ¬¡æ”¶é›†æ‰€æœ‰éœ€è¦çš„è¡Œè»Šæ™‚é–“ï¼Œé€é Google Distance Matrix æ‰¹æ¬¡æŸ¥è©¢ä¸¦å¯«å›æ¯ç­† CRM é …ç›®ï¼Œå…å»å¤šå€‹ HTTP èŠ‚é»ä¸²è¯ã€‚"
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// @ts-ignore - items is provided by n8n runtime\nconst inputItems = (typeof $input !== 'undefined' && $input.all) ? $input.all() : (typeof items !== 'undefined' ? items : []);\nconst firstItem = inputItems[0]?.json || {};\n\n// @ts-ignore - items is provided by n8n runtime\nconst dataRows = Array.isArray(inputItems) ? inputItems.map(item => item.json) : [];\nif ((!Array.isArray(dataRows) || !dataRows.length) && typeof $json !== 'undefined') {\n  if (Array.isArray($json.data)) {\n    dataRows = $json.data;\n  } else if ($json.body && Array.isArray($json.body.data)) {\n    dataRows = $json.body.data;\n  }\n}\n\n// âœ… æ­£ç¢ºçš„ä¸­æ–‡æ¬„ä½åç¨± (é€å‚³æ¬„ä½)\nconst passthroughKeys = [\n  'staffMeta',\n  'staffSheet',\n  'serviceMeta',\n  'serviceSheet',\n  'äº¤é€šç·©è¡(åˆ†é˜)',\n  'submission_date'\n];\n\n/** @type {Record<string, any>} */\nconst passthrough = {};\nfor (let i = 0; i < passthroughKeys.length; i++) {\n  const key = passthroughKeys[i];\n  const value = firstItem[key];\n  if (value !== undefined) {\n    passthrough[key] = value;\n  }\n}\n\n// âœ… æ­£ç¢ºçš„ä¸­æ–‡æ¬„ä½åç¨± (æ–°é ç´„æ¬„ä½)\nconst requestFieldKeys = [\n  'å“ç‰Œ',\n  'æœå‹™',\n  'åœ°å€',\n  'district',  // English field name\n  'å–®ä½å°ºæ•¸ (å¹³æ–¹å°º)',\n  'å•é¡Œåš´é‡ç¨‹åº¦(1-5ç´š)',\n  'é ä¼°æœå‹™æ™‚é–“(åˆ†é˜)',\n  'å›è¨ªä¸­é–“ç©ºæª”(å°æ™‚)',\n  'å›è¨ªåœç•™æ™‚é•·(åˆ†é˜)',\n  'å‚™è¨»',\n  'æäº¤æ—¥æœŸ',\n  'æäº¤æ™‚é–“'\n];\n\n/** @type {Record<string, any>} */\nconst requestMeta = {};\nfor (let i = 0; i < requestFieldKeys.length; i++) {\n  const key = requestFieldKeys[i];\n  const value = firstItem[key];\n  if (value !== undefined) {\n    requestMeta[key] = value;\n  }\n}\n\nconst payload = {\n    ...requestMeta,\n    ...passthrough,\n    data: dataRows\n  };\n        return [{\n    json: payload\n  }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17744,
        12736
      ],
      "id": "197007f8-c9f4-4a1f-96d9-b8c69fb028c0",
      "name": "æ•´åˆé ç´„è³‡æ–™",
      "notesInFlow": "å°‡è™•ç†å¾Œçš„ CRM é …ç›®èˆ‡æ–°å®¢éœ€æ±‚æ¬„ä½æ‰“åŒ…ç‚º data é™£åˆ—ï¼Œæä¾›çµ¦å¾ŒçºŒ AI Agent ä½¿ç”¨ã€‚"
    },
    {
      "parameters": {
        "content": "Webhook æ”¶åˆ°æ–°é ç´„å¾ŒåŒæ™‚åˆ†æˆå…©æ”¯ï¼šä¸€æ”¯æŠ“ CRM 7 æ—¥è¡Œç¨‹ï¼Œä¸€æ”¯ä¿ç•™æ–°å–®è³‡æ–™ï¼Œæœ€å¾Œåœ¨è·é›¢çŸ©é™£ç¯€é»æ•´åˆã€‚"
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        17488,
        12000
      ],
      "id": "96eacac1-8f16-4dd6-90ba-ae6b442aa802",
      "name": "æµç¨‹æ¦‚è¦½"
    },
    {
      "parameters": {
        "content": "è·é›¢ã€å›è¨ªèˆ‡ CRM æ–™æ•´åˆå¾Œäº¤çµ¦ AI Agentï¼Œä¸¦é™„å¸¶ Google Sheet å·¥å…·èˆ‡ GPT æ¨¡å‹åšæ’ç¨‹å»ºè­°ã€‚"
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        18768,
        12848
      ],
      "id": "72722642-9435-4ef7-b393-3ccb25826f09",
      "name": "AI åˆ†æèªªæ˜"
    },
    {
      "parameters": {
        "content": "1. å®¢æˆ¶é ç´„è«‹æ±‚ï¼šWebhook æ¥æ”¶åŸå§‹æ–°å–®è³‡æ–™ï¼ˆHTTP POSTï¼‰ï¼Œè¼¸å…¥èˆ‡è¼¸å‡ºå‡ç‚ºè©² JSONï¼›åŒæ™‚å›å‚³ 202 çµ¦å‰ç«¯ã€‚\n2. æŠ½å‡ºå¿…è¦å­—æ®µï¼šSet ç¯€é»æ“·å–å“ç‰Œã€æœå‹™ã€åœ°å€ã€ä¼°æ™‚ç­‰æ¬„ä½ï¼›ä¸€æ”¯è¼¸å‡ºçµ¦ CRM åˆ†æ”¯ï¼Œå¦ä¸€æ”¯ç›´æ¥é€²è·é›¢çŸ©é™£ä¾›æ–°å–®ä½¿ç”¨ã€‚\n3. ç²å–æœªä¾†7D CRMæ’ç¨‹ï¼šä¾æäº¤æ—¥æœŸå‘¼å« CRM APIï¼Œè¼¸å…¥æ–°å–®æ¬„ä½ï¼Œè¼¸å‡º 7 å¤©è¡Œç¨‹ JSONã€‚\n4. æ‹†åˆ†å‡ºæ¯å€‹é ç´„ï¼šCode ç¯€é»æ‹†åˆ† CRM å›æ‡‰ä¸¦è¨ˆç®—å‰/å¾Œè¨‚å–®ç©ºæª”ï¼Œè¼¸å‡ºé€ç­† CRM è¨‚å–®ã€‚\n5. CRM-æŠ½å‡ºå¿…è¦å­—æ®µï¼šSet ç¯€é»æŠ½å‡º CRM è¨‚å–®æ¬„ä½ï¼ˆåœ°å€ã€è·å“¡ã€å‰å¾Œç©ºæª”ç­‰ï¼‰ï¼Œå†èˆ‡æ–°å–®ä¸€èµ·é€²è·é›¢çŸ©é™£ã€‚\n6. è·é›¢çŸ©é™£æ‰¹æ¬¡ï¼šCode ç¯€é»æŠŠæ–°å–®èˆ‡ CRM è¨‚å–®ä¸€èµ·å‘¼å« Google Distance Matrixï¼Œè¼¸å‡ºè¡Œè»Šæ™‚é–“èˆ‡é€šå‹¤åˆ†é˜æ•¸ã€‚\n7. åˆ¤æ–·å›è¨ªé ç´„ï¼šCode ç¯€é»åˆ¤æ–·æ˜¯å¦éœ€å›è¨ªä¸¦è¨ˆç®—å›è¨ªæ™‚é–“æ¬„ä½ã€‚\n8. æ•´åˆé ç´„è³‡æ–™ï¼šCode ç¯€é»å°‡ CRM è¨‚å–®é™£åˆ— + æ–°å–®æ¬„ä½æ•´åˆçµ¦ AI ä½¿ç”¨ã€‚\n9. æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½ï¼šæ•´ç† free slotsã€è·å“¡è³‡è¨Šç­‰ï¼Œè¼¸å‡ºçµ¦ AI æ”¯ç·šã€‚\n10. è·å“¡ä½å€ â†’ Code2 â†’ è·å“¡åœ°å€ï¼šæº–å‚™è·å“¡ä½å€æ¸…å–®ä¸¦æŸ¥è©¢æ¯ä½è·å“¡åˆ°æ–°å–®çš„é€šå‹¤æ™‚é–“ã€‚\n11. æ•´ç†å„äººçš„å®šèˆ‡æ–°å–®æ™‚é–“ï¼šSet ç¯€é»æ•´ç†é€šå‹¤å­—ä¸²ï¼Œè¼¸å‡ºçµ¦ AI Agentã€‚\n12. AI Agentï¼ˆå« GPT/Google Sheet å·¥å…·ï¼‰ï¼šåˆ†ææ‰€æœ‰è³‡æ–™å¾Œè¼¸å‡ºæ’ç¨‹å»ºè­°ã€‚\n13. Webhookå›è¦†ï¼šRespond to Webhookï¼Œå³æ™‚å›è¦† {status:\\\"queued\\\",â€¦}ï¼Œä¸»æµç¨‹åœ¨èƒŒæ™¯é‹è¡Œã€‚",
        "height": 336,
        "width": 816
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        18160,
        11680
      ],
      "id": "bd483f65-935a-4ab2-98fb-254c27f24bd4",
      "name": "å®Œæˆæµç¨‹èªªæ˜"
    },
    {
      "parameters": {
        "options": {}
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.4,
      "position": [
        20128,
        13184
      ],
      "id": "72b72db7-7f48-48a8-a2e0-4ec1d36ff1cc",
      "name": "Respond to Webhook"
    },
    {
      "parameters": {
        "jsCode": "// å¾é ç´„æå–è·å“¡è³‡æ–™\n// æ­¤ç¯€é»å¾å·²å–å¾—çš„ CRM é ç´„è³‡æ–™ä¸­æå–è·å“¡æ¸…å–®ï¼Œæ›¿ä»£ä¸å­˜åœ¨çš„ /api/staffs/availability API\n\n// å¾è¼¸å…¥ç²å–é ç´„è³‡æ–™ï¼Œä¾†è‡ªã€Œæ•´åˆé ç´„è³‡æ–™ã€ç¯€é»çš„ data é™£åˆ—\nlet appointmentData = [];\nconst inputItems = (typeof $input !== 'undefined' && $input.all) ? $input.all() : (typeof items !== 'undefined' ? items : []);\nif (Array.isArray(inputItems) && inputItems.length && Array.isArray(inputItems[0]?.json?.data)) {\n  appointmentData = inputItems[0].json.data;\n} else if (typeof $json !== 'undefined' && Array.isArray($json.data)) {\n  appointmentData = $json.data;\n}\n\n\ntry {\n  // å¾ $input ç²å–ï¼Œæ¨™æº– n8n æ–¹å¼\n  if (typeof $input !== 'undefined' && $input) {\n    if (typeof $input.first === 'function') {\n      const firstItem = $input.first();\n      if (firstItem && firstItem.json && Array.isArray(firstItem.json.data)) {\n        appointmentData = firstItem.json.data;\n      }\n    } else if (typeof $input.all === 'function') {\n      const allItems = $input.all();\n      if (Array.isArray(allItems) && allItems.length > 0) {\n        const firstItem = allItems[0];\n        if (firstItem && firstItem.json && Array.isArray(firstItem.json.data)) {\n          appointmentData = firstItem.json.data;\n        }\n      }\n    }\n  }\n} catch (e) {\n  }\n\nconst staffMap = new Map();\nconst seenNames = new Set();\n\n// å¾æ¯å€‹é ç´„ä¸­æå–è·å“¡è³‡è¨Š\nfor (const appt of appointmentData) {\n  // appt å¯èƒ½æ˜¯ç‰©ä»¶æˆ–å·²ç¶“åŒ…å« json å±¬æ€§\n  const appointment = appt?.json || appt || {};\n  \n  // æå–ä¸»è¦è·å“¡ï¼ˆå¾ user ç‰©ä»¶æˆ–è² è²¬è·å“¡æ¬„ä½ï¼‰\n  const mainStaff = appointment.user || null;\n  const staffName = appointment['è™•ç†è·å“¡'] || (mainStaff ? (mainStaff.name || mainStaff.fullName || String(mainStaff)) : null);\n  \n  if (staffName) {\n    const cleanName = String(staffName).trim();\n    if (cleanName && !seenNames.has(cleanName)) {\n      seenNames.add(cleanName);\n      staffMap.set(cleanName, {\n        name: cleanName,\n        address: mainStaff?.address || mainStaff?.home_address || mainStaff?.base_location || '',\n        homeDistrict: mainStaff?.district || mainStaff?.home_district || null,\n        workStart: mainStaff?.work_start || mainStaff?.workStart || '09:00',\n        workEnd: mainStaff?.work_end || mainStaff?.workEnd || '18:00',\n        bufferMin: mainStaff?.buffer_min || mainStaff?.buffer || null,\n        skills: mainStaff?.skills || mainStaff?.skillTags || [],\n        status: mainStaff?.status || 'active',\n        isAvailable: mainStaff?.status !== 'inactive' && mainStaff?.status !== 'leave'\n      });\n    }\n  }\n  \n  // æå–é¡å¤–è·å“¡ï¼ˆå¦‚æœè² è²¬è·å“¡æ¬„ä½åŒ…å«å¤šå€‹è·å“¡ï¼Œç”¨ + åˆ†éš”ï¼‰\n  if (staffName && (staffName.includes('+') || staffName.includes('ï¼‹'))) {\n    const names = String(staffName).split(/[+ï¼‹]/).map(n => n.trim()).filter(Boolean);\n    for (const name of names) {\n      if (name && !seenNames.has(name)) {\n        seenNames.add(name);\n        staffMap.set(name, {\n          name: name,\n          address: '',\n          homeDistrict: null,\n          workStart: '09:00',\n          workEnd: '18:00',\n          bufferMin: null,\n          skills: [],\n          status: 'active',\n          isAvailable: true\n        });\n      }\n    }\n  }\n}\n\n// è½‰æ›ç‚ºé™£åˆ—æ ¼å¼\nconst staffList = Array.from(staffMap.values());\nconst staffMeta = staffList.map(staff => ({\n  name: staff.name,\n  work_start: staff.workStart,\n  work_end: staff.workEnd,\n  home_district: staff.homeDistrict,\n  buffer_min: staff.bufferMin,\n  skills: Array.isArray(staff.skills) ? staff.skills : [],\n  exclude: !staff.isAvailable\n}));\n\n// å¦‚æœæ²’æœ‰å¾é ç´„ä¸­æå–åˆ°è·å“¡è³‡æ–™ï¼Œè¿”å›ç©ºé™£åˆ—ï¼Œå°‡ä¾è³´ Google Sheets\nreturn [{\n  json: {\n    staffList: staffList.length > 0 ? staffList : [],\n    staffMeta: staffMeta.length > 0 ? staffMeta : [],\n    staffSource: {\n      totalFetched: staffList.length,\n      uniqueNames: staffList.length,\n      source: 'appointments',\n      note: staffList.length === 0 ? 'æœªå¾é ç´„è³‡æ–™ä¸­æå–åˆ°è·å“¡è³‡è¨Šï¼Œå°‡ä½¿ç”¨ Google Sheets è³‡æ–™' : 'å¾é ç´„è³‡æ–™ä¸­æå–è·å“¡è³‡è¨Š',\n      fetchedAt: new Date().toISOString()\n    }\n  }\n}];\nconsole.log('[å¾é ç´„æå–è·å“¡è³‡æ–™] Staff meta entries:', staffMeta.length);"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18160,
        12448
      ],
      "id": "d17596a3-39b3-487e-864e-50cfeb476677",
      "name": "å¾é ç´„æå–è·å“¡è³‡æ–™",
      "notesInFlow": "æ›¿ä»£ä¸å­˜åœ¨çš„ /api/staffs/availability APIã€‚å¾å·²å–å¾—çš„ CRM é ç´„è³‡æ–™ä¸­æå–è·å“¡è³‡è¨Šã€‚å¦‚æœæ²’æœ‰æå–åˆ°è³‡æ–™ï¼Œå°‡ä¾è³´ Google Sheets çš„è·å“¡è¨­å®šã€‚"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        18944,
        12096
      ],
      "id": "2ecd071b-6770-42ac-ace8-40020a96373f",
      "name": "åˆä½µCRMè³‡æ–™"
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1Fev9gNZ65LDN79xULz3VNjKdpxLv9wpNl9VVpMk9Wuk",
          "mode": "list",
          "cachedResultName": "æ’ç¨‹é ç´„è³‡æ–™",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1Fev9gNZ65LDN79xULz3VNjKdpxLv9wpNl9VVpMk9Wuk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 1959873114,
          "mode": "list",
          "cachedResultName": "äººå“¡æ™‚é–“åŠæŠ€èƒ½èˆ‡äº‹é …",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1Fev9gNZ65LDN79xULz3VNjKdpxLv9wpNl9VVpMk9Wuk/edit#gid=1959873114"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        18480,
        12480
      ],
      "id": "af309104-4823-4775-8bd9-7eba1b72be41",
      "name": "Staff_Config",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyeDwKkJiSG26Qg5",
          "name": "Google Sheets account 3"
        }
      }
    },
    {
      "parameters": {
        "documentId": {
          "__rl": true,
          "value": "1Fev9gNZ65LDN79xULz3VNjKdpxLv9wpNl9VVpMk9Wuk",
          "mode": "list",
          "cachedResultName": "æ’ç¨‹é ç´„è³‡æ–™",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1Fev9gNZ65LDN79xULz3VNjKdpxLv9wpNl9VVpMk9Wuk/edit?usp=drivesdk"
        },
        "sheetName": {
          "__rl": true,
          "value": 0,
          "mode": "list",
          "cachedResultName": "æœå‹™åŸºæº–æ™‚é–“",
          "cachedResultUrl": "https://docs.google.com/spreadsheets/d/1Fev9gNZ65LDN79xULz3VNjKdpxLv9wpNl9VVpMk9Wuk/edit#gid=0"
        },
        "options": {}
      },
      "type": "n8n-nodes-base.googleSheets",
      "typeVersion": 4.5,
      "position": [
        18480,
        12656
      ],
      "id": "63aa4e57-bfb3-4219-89eb-ec621944c6c0",
      "name": "Service_Config",
      "credentials": {
        "googleSheetsOAuth2Api": {
          "id": "UyeDwKkJiSG26Qg5",
          "name": "Google Sheets account 3"
        }
      }
    },
    {
      "parameters": {
        "jsCode": "// æ•´ç† Google Sheets è·å“¡è³‡æ–™ä¸¦è§£æé–‹å·¥/æ”¶å·¥æ™‚æ®µ\n// âœ… UPDATED: Added debug logging and fuzzy å±…ä½åœ° column matching\nconst items = $input.all();\nconst rawRows = Array.isArray(items) ? items.map(item => item.json || {}).filter(row => Object.keys(row).length > 0) : [];\n\n// ============================================\n// ğŸ” DEBUG: Show all column names from Google Sheets\n// ============================================\nif (rawRows.length > 0) {\n  const firstRow = rawRows[0];\n  const columnNames = Object.keys(firstRow);\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] ========== DEBUG ==========');\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] ğŸ“‹ All column names from Google Sheets:');\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™]   ', columnNames.join(', '));\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] ğŸ“Š Total rows:', rawRows.length);\n\n  // Check for å±…ä½åœ° related columns\n  const addressColumns = columnNames.filter(col =>\n    col.includes('å±…ä½') || col.includes('ä½å€') || col.includes('åœ°å€') ||\n    col.includes('district') || col.includes('address') || col.includes('åœ°å€')\n  );\n  if (addressColumns.length > 0) {\n    console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] âœ… Found address-related columns:', addressColumns.join(', '));\n  } else {\n    console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] âš ï¸ No address-related columns found!');\n  }\n\n  // Show sample values for first 3 rows\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] ğŸ“Š Sample data (first 3 rows):');\n  rawRows.slice(0, 3).forEach((row, i) => {\n    const name = row['è·å“¡'] || row['name'] || row['Name'] || '(no name)';\n    // Try to find home district with various column names\n    const possibleAddressKeys = ['å±…ä½åœ°', 'å±…ä½åœ°å€', 'ä½å€', 'åœ°å€', 'home_district', 'homeDistrict', 'address'];\n    let homeDistrict = null;\n    let foundKey = null;\n    for (const key of possibleAddressKeys) {\n      if (row[key] && String(row[key]).trim()) {\n        homeDistrict = row[key];\n        foundKey = key;\n        break;\n      }\n    }\n    // Also try fuzzy match\n    if (!homeDistrict) {\n      for (const key of Object.keys(row)) {\n        if (key.includes('å±…ä½') || key.includes('ä½å€')) {\n          homeDistrict = row[key];\n          foundKey = key + ' (fuzzy)';\n          break;\n        }\n      }\n    }\n    console.log(`[æ•´ç†Googleè·å“¡è³‡æ–™]   Row ${i}: ${name} â†’ ${foundKey || '(no key)'}: \"${homeDistrict || '(empty)'}\"`);\n  });\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] ========== END DEBUG ==========');\n}\n\n// ============================================\n// Helper Functions\n// ============================================\n\n// è§£ææŠ€èƒ½æ¨™ç±¤å‡½æ•¸\nconst parseSkills = (skillsStr) => {\n  if (!skillsStr || typeof skillsStr !== 'string') {\n    return [];\n  }\n  // æ”¯æ´å¤šç¨®åˆ†éš”ç¬¦: , ï¼Œ ã€ | /\n  return skillsStr\n    .split(/[,ï¼Œã€|/]/)\n    .map(s => s.trim())\n    .filter(Boolean);\n};\n\n// æ¸…ç†æ™‚é–“æ ¼å¼ï¼ˆç§»é™¤ç©ºæ ¼ï¼Œçµ±ä¸€æ ¼å¼ï¼‰\nconst cleanTimeStr = (timeStr) => {\n  if (!timeStr || typeof timeStr !== 'string') return null;\n  return timeStr.trim().replace(/\\s+/g, '');\n};\n\n// âœ… NEW: Fuzzy find home district from row with multiple possible column names\nconst findHomeDistrict = (row) => {\n  if (!row || typeof row !== 'object') return null;\n\n  // Priority 1: Exact column names\n  const exactKeys = ['å±…ä½åœ°', 'å±…ä½åœ°å€', 'ä½å€', 'åœ°å€', 'home_district', 'homeDistrict'];\n  for (const key of exactKeys) {\n    const val = row[key];\n    if (val !== undefined && val !== null && String(val).trim()) {\n      return String(val).trim();\n    }\n  }\n\n  // Priority 2: Fuzzy match - columns containing these keywords\n  const fuzzyPatterns = ['å±…ä½', 'ä½å€', 'åœ°å€'];\n  for (const key of Object.keys(row)) {\n    for (const pattern of fuzzyPatterns) {\n      if (key.includes(pattern)) {\n        const val = row[key];\n        if (val !== undefined && val !== null && String(val).trim()) {\n          console.log(`[æ•´ç†Googleè·å“¡è³‡æ–™] ğŸ” Fuzzy matched column \"${key}\" for home district`);\n          return String(val).trim();\n        }\n      }\n    }\n  }\n\n  return null;\n};\n\n// ============================================\n// Process each row\n// ============================================\nconst rows = rawRows.map(row => {\n  // ç›´æ¥å¾ã€Œé–‹å·¥æ™‚æ®µã€å’Œã€Œæ”¶å·¥æ™‚æ®µã€æ¬„ä½è®€å–\n  const workStart = cleanTimeStr(row['é–‹å·¥æ™‚æ®µ'] || row['work_start'] || '');\n  const workEnd = cleanTimeStr(row['æ”¶å·¥æ™‚æ®µ'] || row['work_end'] || '');\n\n  const skillsStr = row['æŠ€èƒ½æ¨™ç±¤'] || row['skills'] || row['æŠ€èƒ½'] || '';\n  const skills = parseSkills(skillsStr);\n\n  const maxJobsPerDay = parseInt(row['æœ€å¤§å–®æ•¸/å¤©'] || row['max_jobs_per_day'] || '0') || null;\n\n  const hasWorkHours = !!(workStart && workEnd);\n\n  // âœ… NEW: Extract home district using fuzzy matching\n  const homeDistrict = findHomeDistrict(row);\n\n  // ä¿ç•™åŸå§‹æ•¸æ“š + æ·»åŠ è§£æå¾Œçš„æ•¸æ“š\n  return {\n    ...row,\n    // âœ… Ensure home_district is explicitly set at top level for downstream nodes\n    home_district: homeDistrict,\n    _parsed: {\n      work_start: workStart || '09:00',  // é è¨­ 09:00\n      work_end: workEnd || '18:00',      // é è¨­ 18:00\n      skills: skills.length > 0 ? skills : ['*'],  // é è¨­å…è¨±æ‰€æœ‰\n      max_jobs_per_day: maxJobsPerDay,\n      has_work_hours: hasWorkHours,\n      has_skills: skills.length > 0,\n      home_district: homeDistrict  // âœ… Also store in _parsed\n    }\n  };\n});\n\n// ============================================\n// Statistics\n// ============================================\nconst stats = {\n  total: rows.length,\n  with_work_hours: rows.filter(r => r._parsed.has_work_hours).length,\n  with_skills: rows.filter(r => r._parsed.has_skills).length,\n  with_max_jobs: rows.filter(r => r._parsed.max_jobs_per_day).length,\n  with_home_district: rows.filter(r => r._parsed.home_district).length  // âœ… NEW\n};\n\nconsole.log('[æ•´ç†Googleè·å“¡è³‡æ–™] ğŸ“Š Parse stats:', JSON.stringify(stats));\nconsole.log(`[æ•´ç†Googleè·å“¡è³‡æ–™] âœ… æœ‰å±…ä½åœ°çš„è·å“¡: ${stats.with_home_district}/${stats.total}`);\n\nif (stats.with_home_district === 0 && stats.total > 0) {\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] âš ï¸âš ï¸âš ï¸ WARNING: No staff have home district data!');\n  console.log('[æ•´ç†Googleè·å“¡è³‡æ–™] è«‹ç¢ºèª Google Sheets æœ‰ã€Œå±…ä½åœ°ã€æ¬„ä½ä¸¦å¡«å¯«æ•¸æ“š');\n}\n\nreturn [{\n  json: {\n    staffSheet: rows,\n    staffSheetCount: rows.length,\n    _parseStats: stats\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18736,
        12464
      ],
      "id": "7f7e4728-0b70-4ba4-824f-41c5acc84143",
      "name": "æ•´ç†Googleè·å“¡è³‡æ–™"
    },
    {
      "parameters": {
        "jsCode": "// åˆä½µå¤šå€‹æ•¸æ“šæºï¼ˆæ”¯æŒå¤šè¼¸å…¥ï¼‰\n// âœ… UPDATED: Use $('Service_Config').all() for direct node reference\nconst items = $input.all();\nconsole.log(`[åˆä½µStaffè¨­å®š] ğŸ“Š Total inputs:`, items.length);\n\n// Input 0: Main data flow (CRM + Staff)\n\nlet crmData = [];\nlet staffData = [];\nlet googleData = [];\nlet serviceData = [];\n\n// âœ… FIXED: Get Service Sheet using direct node reference instead of input index\ntry {\n  const serviceNodeData = $('Service_Config').all();\n  if (serviceNodeData && serviceNodeData.length > 0) {\n    serviceData = serviceNodeData.map(item => item.json);\n    console.log(`[åˆä½µStaffè¨­å®š] âœ… å¾ Service_Config ç¯€é»ç²å– serviceSheet:`, serviceData.length, 'ç­†');\n  }\n} catch (e) {\n  console.log(`[åˆä½µStaffè¨­å®š] âš ï¸ ç„¡æ³•ç²å–ç¯€é» Service_Config:`, String(e));\n}\n\n// Fallback: prefer merged input serviceSheet (from åˆä½µServiceè¨­å®š)\nif (!serviceData || serviceData.length === 0) {\n  for (const it of items) {\n    const j = (it && it.json) || {};\n    if (Array.isArray(j.serviceSheet) && j.serviceSheet.length > 0) {\n      serviceData = j.serviceSheet;\n      console.log(`[åˆä½µStaffè¨­å®š] âœ… å¾ merged input å–å¾— serviceSheet: ${serviceData.length} ç­†`);\n      break;\n    }\n  }\n}\n\n// Get other data using node references\ntry {\n  const crmNodeData = $('æ•´åˆé ç´„è³‡æ–™').all();\n  if (crmNodeData && crmNodeData.length > 0) {\n    crmData = crmNodeData.map(item => item.json);\n  }\n} catch (e) {\n  console.log(`[åˆä½µStaffè¨­å®š] âš ï¸ ç„¡æ³•ç²å–ç¯€é» æ•´åˆé ç´„è³‡æ–™:`, String(e));\n}\n\ntry {\n  const staffNodeData = $('å¾é ç´„æå–è·å“¡è³‡æ–™').all();\n  if (staffNodeData && staffNodeData.length > 0) {\n    staffData = staffNodeData.map(item => item.json);\n  }\n} catch (e) {\n  console.log(`[åˆä½µStaffè¨­å®š] âš ï¸ ç„¡æ³•ç²å–ç¯€é» å¾é ç´„æå–è·å“¡è³‡æ–™:`, String(e));\n}\n\ntry {\n  const googleNodeData = $('æ•´ç†Googleè·å“¡è³‡æ–™').all();\n  if (googleNodeData && googleNodeData.length > 0) {\n    googleData = googleNodeData.map(item => item.json);\n  }\n} catch (e) {\n  console.log(`[åˆä½µStaffè¨­å®š] âš ï¸ ç„¡æ³•ç²å–ç¯€é» æ•´ç†Googleè·å“¡è³‡æ–™:`, String(e));\n}\n\n// åˆä½µæ‰€æœ‰æ•¸æ“š\nconst merged = {};\n\n// 1. å¾ CRM æ•¸æ“šç²å–åŸºç¤è³‡æ–™\nif (crmData.length > 0) {\n  Object.assign(merged, crmData[0]);\n}\n\n// 2. å¾è·å“¡æ•¸æ“šç²å– staffList å’Œ staffMeta\nif (staffData.length > 0) {\n  const staff = staffData[0];\n  if (Array.isArray(staff.staffList)) {\n    merged.staffList = staff.staffList;\n  }\n  if (Array.isArray(staff.staffMeta)) {\n    merged.staffMeta = staff.staffMeta;\n  }\n  if (staff.staffSource) {\n    merged.staffSource = staff.staffSource;\n  }\n}\n\n// 3. å¾ Google Sheets ç²å– staffSheet\nif (googleData.length > 0) {\n  const google = googleData[0];\n  if (Array.isArray(google.staffSheet)) {\n    merged.staffSheet = google.staffSheet;\n    merged.staffSheetCount = google.staffSheet.length;\n    const parsedCount = google.staffSheet.filter(r => r._parsed).length;\n    console.log(`[åˆä½µStaffè¨­å®š] âœ… staffSheet: ${google.staffSheet.length} ç­† (å·²è§£æ: ${parsedCount})`);\n  } else {\n    merged.staffSheetCount = 0;\n  }\n} else {\n  merged.staffSheetCount = 0;\n}\n\n// âœ… 4. å¾ Service_Config ç²å– serviceSheet\nif (serviceData.length > 0) {\n  // Google Sheets returns array of row objects\n  merged.serviceSheet = serviceData;\n  merged.serviceSheetCount = serviceData.length;\n  console.log(`[åˆä½µStaffè¨­å®š] âœ… serviceSheet: ${serviceData.length} ç­†`);\n\n  // Debug: Show column names\n  if (serviceData.length > 0) {\n    const firstRow = serviceData[0];\n    const keys = Object.keys(firstRow);\n    console.log(`[åˆä½µStaffè¨­å®š] ğŸ“‹ serviceSheet æ¬„ä½:`, keys.slice(0, 10).join(', '));\n\n    // Check if \"æ—©ä¸Šæ¸…æ½”\" column exists\n    if ('æ—©ä¸Šæ¸…æ½”' in firstRow) {\n      console.log(`[åˆä½µStaffè¨­å®š] âœ… æ‰¾åˆ° \"æ—©ä¸Šæ¸…æ½”\" æ¬„ä½`);\n      // Count how many services require morning cleaning\n      const morningCount = serviceData.filter(row => /^Y$/i.test(String(row['æ—©ä¸Šæ¸…æ½”'] || '').trim())).length;\n      console.log(`[åˆä½µStaffè¨­å®š] ğŸ“Š éœ€è¦æ—©ä¸Šæ¸…æ½”çš„æœå‹™: ${morningCount} å€‹`);\n    } else {\n      console.log(`[åˆä½µStaffè¨­å®š] âš ï¸ æœªæ‰¾åˆ° \"æ—©ä¸Šæ¸…æ½”\" æ¬„ä½ï¼Œå¯ç”¨æ¬„ä½:`, keys.join(', '));\n    }\n  }\n} else {\n  merged.serviceSheet = [];\n  merged.serviceSheetCount = 0;\n  console.log(`[åˆä½µStaffè¨­å®š] âš ï¸ æ²’æœ‰ serviceSheet æ•¸æ“š`);\n}\n\n// æœ€çµ‚çµ±è¨ˆ\nconst dataLength = Array.isArray(merged['data']) ? merged['data'].length : 0;\nconst finalStats = {\n  dataLength,\n  staffListLength: merged.staffList ? merged.staffList.length : 0,\n  staffSheetCount: merged.staffSheetCount || 0,\n  serviceSheetCount: merged.serviceSheetCount || 0,\n  hasStaffMeta: !!merged.staffMeta\n};\n\nconsole.log('[åˆä½µStaffè¨­å®š] âœ… åˆä½µå®Œæˆ:', JSON.stringify(finalStats));\n\nreturn [{ json: merged }];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        19328,
        12432
      ],
      "id": "2283b135-4bb5-4551-ad6c-9b7b1c1f3847",
      "name": "åˆä½µStaffè¨­å®š",
      "alwaysOutputData": true
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// Input is now a merged item containing both Staff Data (from Input 1) and Maps Data (from Input 2)\n// âœ… UPDATED: Use index-based matching via staffOrder (Google returns results in same order)\n\nconst item = $input.first().json;\n\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ========== é–‹å§‹è™•ç† ==========');\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š Input keys:', Object.keys(item).slice(0, 15));\n\n// 1. Get Staff List (from 'æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½')\nconst staffList = item.staffList || [];\nconst staffCfg = item.staffCfg || {};\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š staffList length:', staffList.length);\nif (staffList.length > 0) {\n  console.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š First 3 staff:', staffList.slice(0, 3).map(s => s.name || s));\n}\n\n// 2. Get Maps Data (from 'è·å“¡åœ°å€')\nconst rows = item.rows || [];\nconst staffAddresses = item.origin_addresses || [];\nconst jobAddresses = item.destination_addresses || [];\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š rows (Maps API) length:', rows.length);\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š staffAddresses length:', staffAddresses.length);\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š jobAddresses length:', jobAddresses.length);\n\n// âœ… FIX: Get staffOrder from _mapsParams for index-based matching\nconst mapsParams = item._mapsParams || {};\nconst staffOrder = mapsParams.staffOrder || [];\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š staffOrder length:', staffOrder.length);\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ğŸ“‹ staffOrder:', staffOrder.join(', '));\n\n// ========================================\n// âœ… FIX: Build staffCommute using INDEX-BASED matching\n// Google Maps returns results in the same order as input addresses\n// ========================================\nconst staffCommute = [];\n\n// Process each row from Google Maps using INDEX\nfor (let i = 0; i < rows.length; i++) {\n  const row = rows[i] || {};\n  const googleAddr = staffAddresses[i] || '';\n\n  // âœ… FIX: Use staffOrder[i] instead of address matching\n  const staffName = staffOrder[i] || null;\n\n  if (!staffName) {\n    console.log(`[æ•´ç†è·å“¡é€šå‹¤] âš ï¸ No staff at index ${i} (Google addr: \"${googleAddr}\")`);\n    continue;\n  }\n\n  // Get commute time from Google Maps response\n  const element = (row.elements && row.elements.length > 0) ? row.elements[0] : null;\n\n  let duration = null;\n  let durationText = null;\n  let distanceText = null;\n\n  if (element && element.status === 'OK') {\n    if (element.duration) {\n      duration = element.duration.value;  // seconds\n      durationText = element.duration.text;\n    }\n    if (element.distance) {\n      distanceText = element.distance.text;\n    }\n  } else {\n    console.log(`[æ•´ç†è·å“¡é€šå‹¤] âš ï¸ ${staffName}: Google Maps element status = ${element?.status || 'missing'}`);\n  }\n\n  const travelMinutes = (duration && duration > 0) ? Math.round(duration / 60) : null;\n\n  staffCommute.push({\n    name: staffName,\n    address: googleAddr,\n    rawAddress: staffCfg[staffName]?.home_district || '',\n    isAvailable: true,\n    travelText: durationText,\n    travelMinutes: travelMinutes,\n    distanceText: distanceText\n  });\n\n  console.log(`[æ•´ç†è·å“¡é€šå‹¤] âœ… [${i}] ${staffName}: ${travelMinutes || '?'} åˆ†é˜ (${distanceText || '?'})`);\n}\n\n// ========================================\n// Also include staff without valid addresses (with null commute time)\n// ========================================\nconst staffWithCommute = new Set(staffCommute.map(c => c.name));\nfor (const staff of staffList) {\n  const staffName = typeof staff === 'string' ? staff : (staff?.name || '');\n  if (!staffName) continue;\n\n  if (!staffWithCommute.has(staffName)) {\n    const cfg = staffCfg[staffName] || {};\n    staffCommute.push({\n      name: staffName,\n      address: cfg.home_district || '',\n      rawAddress: cfg.home_district || '',\n      isAvailable: true,\n      travelText: null,\n      travelMinutes: null,  // No commute data\n      distanceText: null\n    });\n    console.log(`[æ•´ç†è·å“¡é€šå‹¤] âš ï¸ ${staffName}: ç„¡é€šå‹¤æ•¸æ“š (åœ°å€: ${cfg.home_district || 'ç„¡'})`);\n  }\n}\n\nconsole.log(`[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š æœ€çµ‚ staffCommute: ${staffCommute.length} ä½è·å“¡`);\nconsole.log(`[æ•´ç†è·å“¡é€šå‹¤] ğŸ“Š æœ‰é€šå‹¤æ•¸æ“š: ${staffCommute.filter(c => c.travelMinutes != null).length} ä½`);\n\n// Calculate current date and window for AI validation\nconst now = new Date();\nconst hkNow = new Date(now.getTime() + 8 * 60 * 60000 - now.getTimezoneOffset() * 60000);\nconst currentDate = hkNow.toISOString().split('T')[0];\n\n// Get window dates from merged data if available\nconst windowStart = item.windowStart || null;\nconst windowEnd = item.windowEnd || null;\n\nconsole.log('[æ•´ç†è·å“¡é€šå‹¤] ========== è™•ç†å®Œæˆ ==========');\n\nreturn [{\n  json: {\n    ...item,\n    staffCommute,\n    staffAddresses,\n    jobAddresses,\n    elementsCount: rows.length,\n    currentDate,\n    windowStart,\n    windowEnd,\n    validDateRange: windowStart && windowEnd ? `${windowStart} to ${windowEnd}` : null\n  }\n}];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        19120,
        13024
      ],
      "id": "7957af02-fa9d-4aaf-ac44-555981396765",
      "name": "æ•´ç†è·å“¡é€šå‹¤æ‘˜è¦"
    },
    {
      "parameters": {
        "jsCode": "// Validate required fields on incoming payload\nconst inputItems = (typeof $input !== 'undefined' && $input.all) ? $input.all() : (Array.isArray(items) ? items : []);\nif (!Array.isArray(inputItems) || inputItems.length === 0) {\n  throw new Error('Validate Input: no payload items received');\n}\nconsole.log('[Validate Input] Received items:', inputItems.length);\n\ninputItems.forEach((item, index) => {\n  const json = item?.json ?? {};\n  const data = json.body ?? json;\n  if (!data || typeof data !== 'object') {\n    throw new Error(`Validate Input: invalid payload at index ${index}`);\n  }\n\n  console.log('[Validate Input] Checking payload keys', Object.keys(data));\n\n  const brand = typeof data.brandName === 'string' ? data.brandName.trim() : '';\n  const service = typeof data.serviceName === 'string' ? data.serviceName.trim() : '';\n  const area = typeof data.mainAreaName === 'string' ? data.mainAreaName.trim() : '';\n\n  if (!brand || !service || !area) {\n    console.error('[Validate Input] Missing fields', {\n      index,\n      hasBrand: !!brand,\n      hasService: !!service,\n      hasArea: !!area,\n    });\n    throw new Error('Missing required fields: brandName, serviceName, or mainAreaName');\n  }\n});\n\nreturn inputItems;\n"
      },
      "name": "Validate Input",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        17824,
        11872
      ],
      "id": "d3218b86-4daf-4c04-8de6-a0f4df7185bb"
    },
    {
      "parameters": {
        "jsCode": "// Build dynamic prompts - Use ONLY filtered allCandidates\nconst items = $input.all();\nconst inputData = items[0].json;\n\n// Get current HK time\nconst now = new Date();\nconst hkNow = new Date(now.getTime() + 8 * 60 * 60000);\nconst currentDateTime = hkNow.toISOString().slice(0, 16).replace('T', ' ');\nconst currentDate = hkNow.toISOString().slice(0, 10);\n\n// Get window dates\nconst windowStart = inputData.windowStart || currentDate;\nconst windowEnd = inputData.windowEnd || currentDate;\n\n// Get service info\nconst serviceInfo = inputData['æœå‹™'] || inputData.service || '';\nconst serviceLocation = inputData['åœ°å€'] || inputData.district || '';\nconst estimatedTime = inputData['é ä¼°æœå‹™æ™‚é–“(åˆ†é˜)'] || '';\nconst submissionDate = inputData['æäº¤æ—¥æœŸ'] || '';\nconst submissionTime = inputData['æäº¤æ™‚é–“'] || '';\nconst brandName = inputData['å“ç‰Œ'] || '';\n\n// Get filtered candidates\nconst allCandidates = inputData.allCandidates || [];\nconst totalBeforeLimit = inputData.allCandidatesBeforeLimit || allCandidates.length;\n\n// Format candidates for better readability\nconst formattedCandidates = allCandidates.slice(0, 20).map((c, idx) => ({\n  index: idx + 1,\n  staff: c.staff,\n  date: c.date,\n  time: c.start + '-' + c.end,\n  score: c.qualityScore,\n  reasons: c.reasons || [],\n  constraints: c.constraints || {}\n}));\n\n// âœ… Optimized System Prompt\nconst systemPrompt = \"ä½ æ˜¯ PestKiller AI æ’ç¨‹åŠ©æ‰‹ï¼Œè² è²¬å¾å·²éæ¿¾çš„å€™é¸æ™‚æ®µä¸­æŒ‘é¸æœ€ä½³æ’ç¨‹æ–¹æ¡ˆã€‚\\n\\nâš ï¸ é‡è¦ï¼šæ‰€æœ‰éœ€è¦çš„æ•¸æ“šå·²åœ¨ä¸‹æ–¹æä¾›ï¼Œè«‹ç›´æ¥åˆ†æä¸¦è¼¸å‡º JSONï¼Œä¸è¦èª¿ç”¨ä»»ä½•å¤–éƒ¨å·¥å…·æˆ– APIã€‚\\n\\nğŸ“Š è¼¸å…¥æ•¸æ“š\\n- allCandidates: å·²å®Œå…¨éæ¿¾ä¸¦è©•åˆ†çš„å¯ç”¨æ™‚æ®µï¼ˆ\" + allCandidates.length + \" å€‹ï¼‰\\n- æ™‚æ®µå·²æŒ‰æ—¥æœŸæ’åºï¼ˆå¾æ—©åˆ°æ™šï¼‰\\n- æ¯ä½è·å“¡æ¯å¤©æœ€å¤š 2 å€‹æ™‚æ®µ\\n- åŒ…å« qualityScoreï¼ˆè©•åˆ†ï¼‰å’Œ reasonsï¼ˆè©•åˆ†åŸå› ï¼‰\\n\\nğŸ¯ ä½ çš„ä»»å‹™\\nå¾å€™é¸æ™‚æ®µä¸­é¸å‡º **æœ€å„ªæ’ç¨‹æ–¹æ¡ˆ**ï¼Œè€ƒæ…®ï¼š\\n1. **åˆ†æ•¸å„ªå…ˆ**ï¼šå„ªå…ˆé¸æ“‡é«˜åˆ†æ™‚æ®µï¼ˆhasNoJobsToday çš„è·å“¡å¾—åˆ†æ›´é«˜ï¼‰\\n2. **å…¬å¹³åˆ†é…**ï¼šé¿å…åŒä¸€è·å“¡é€£çºŒå¤šå¤©è¢«é¸ä¸­ï¼Œè®“æ›´å¤šè·å“¡æœ‰æ©Ÿæœƒ\\n3. **æ—¥æœŸåˆ†æ•£**ï¼šç›¡é‡è¦†è“‹å¤šå€‹æ—¥æœŸï¼Œè€Œéé›†ä¸­åœ¨åŒä¸€å¤©\\n4. **æ¯å¤© 2 äºº**ï¼šæ¯å€‹æ—¥æœŸé¸æ“‡ 2 ä½ä¸åŒè·å“¡ï¼ˆè‹¥å¯ç”¨ï¼‰\\n\\nâš ï¸ é™åˆ¶æ¢ä»¶\\n- åªèƒ½å¾ allCandidates ä¸­é¸æ“‡ï¼Œä¸å¯å‰µé€ æ–°æ™‚æ®µ\\n- æ—¥æœŸç¯„åœï¼š\" + windowStart + \" è‡³ \" + windowEnd + \"\\n- å¦‚æœ allCandidates ç‚ºç©ºï¼Œè¿”å› { \\\"recommendations\\\": [], \\\"status\\\": \\\"no_recommendations\\\" }\\n\\nğŸ“‹ è¼¸å‡ºæ ¼å¼ï¼ˆç´” JSONï¼‰\\n{\\n  \\\"recommendations\\\": [\\n    {\\n      \\\"rank\\\": 1,\\n      \\\"staff\\\": \\\"è·å“¡åç¨±\\\",\\n      \\\"date\\\": \\\"YYYY-MM-DD\\\",\\n      \\\"startTime\\\": \\\"HH:MM\\\",\\n      \\\"endTime\\\": \\\"HH:MM\\\",\\n      \\\"qualityScore\\\": 130,\\n      \\\"reasons\\\": [\\\"åŸå› èªªæ˜\\\"],\\n      \\\"constraints\\\": {}\\n    }\\n  ],\\n  \\\"meta\\\": {\\n    \\\"totalOptionsEvaluated\\\": \" + allCandidates.length + \",\\n    \\\"requiresHumanConfirmation\\\": true,\\n    \\\"disclaimer\\\": \\\"AI å»ºè­°éœ€äººå·¥ç¢ºèª\\\"\\n  }\\n}\\n\\né‡è¦ï¼š\\n- å¿…é ˆæŒ‰æ—¥æœŸæ’åºï¼ˆå¾æ—©åˆ°æ™šï¼‰\\n- constraints å¿…é ˆæ˜¯æœ‰æ•ˆ JSON ç‰©ä»¶ï¼ˆå¯ç‚ºç©º {}ï¼‰\\n- åªè¼¸å‡º JSONï¼Œç„¡å…¶ä»–æ–‡å­—\\n- âš ï¸ JSON æ ¼å¼ï¼šä¸å¯æœ‰å°¾éš¨é€—è™Ÿï¼ˆtrailing commaï¼‰\";\n\n// âœ… Optimized User Prompt\nconst userPrompt = \"ğŸ“‹ æ–°é ç´„\\nå“ç‰Œï¼š\" + brandName + \" | æœå‹™ï¼š\" + serviceInfo + \" | åœ°é»ï¼š\" + serviceLocation + \"\\næ™‚é•·ï¼š\" + estimatedTime + \" åˆ†é˜ | æäº¤ï¼š\" + submissionDate + \" \" + submissionTime + \"\\n\\nğŸ“… æ’ç¨‹çª—å£ï¼š\" + windowStart + \" è‡³ \" + windowEnd + \"\\n\\nâœ… å¯ç”¨æ™‚æ®µï¼ˆå…± \" + allCandidates.length + \" å€‹\" + (totalBeforeLimit > allCandidates.length ? \"ï¼Œéæ¿¾å‰: \" + totalBeforeLimit + \" å€‹\" : \"\") + \"ï¼‰\\n\\n\" + JSON.stringify(formattedCandidates, null, 2) + \"\\n\\n\" + (allCandidates.length > 20 ? \"\\n(åƒ…é¡¯ç¤ºå‰ 20 å€‹ï¼Œå…± \" + allCandidates.length + \" å€‹å¯ç”¨æ™‚æ®µ)\\n\" : \"\") + \"\\n---\\n\\nğŸ¯ è«‹é¸æ“‡æœ€ä½³æ’ç¨‹æ–¹æ¡ˆ\\n- å„ªå…ˆè€ƒæ…®é«˜åˆ†æ™‚æ®µï¼ˆhasNoJobsToday è·å“¡å„ªå…ˆï¼‰\\n- å…¬å¹³åˆ†é…çµ¦ä¸åŒè·å“¡\\n- æ¯å€‹æ—¥æœŸé¸ 2 ä½ä¸åŒè·å“¡\\n- æŒ‰æ—¥æœŸé †åºè¿”å›ï¼ˆå¾æ—©åˆ°æ™šï¼‰\\n\\nè¿”å› JSON æ ¼å¼çš„æ’ç¨‹å»ºè­°ã€‚\";\n\nconsole.log('[System Prompt] å€™é¸æ•¸:', allCandidates.length, '(éæ¿¾å‰:', totalBeforeLimit, ')');\nconsole.log('[System Prompt] æœå‹™:', serviceInfo, 'åœ°é»:', serviceLocation);\nconsole.log('[System Prompt] çª—å£:', windowStart, 'è‡³', windowEnd);\n\nreturn [{\n  json: {\n    ...inputData,\n    system_prompt: systemPrompt,\n    user_prompt_debug: userPrompt\n  }\n}];\n"
      },
      "name": "Set System Prompt",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        19088,
        13600
      ],
      "id": "c2aeead8-7344-48d0-849f-84379c682c06"
    },
    {
      "parameters": {
        "content": "AI è³‡æ–™æº–å‚™ (é‡æ§‹å¾Œ)ï¼š\næ¨¡çµ„åŒ–ç¨‹å¼ç¢¼ä»¥ï¼š\n1. è§£æé ç´„èˆ‡å‡æœŸ\n2. è¨ˆç®—ç©ºé–’æ™‚æ®µ\n3. ä¾å¯ç”¨æ€§ç¯©é¸è·å“¡\n4. å„ªåŒ–æ•ˆèƒ½",
        "height": 172,
        "width": 300
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        18400,
        12656
      ],
      "id": "32c2f73f-1d53-44c9-aef0-589a10e2e08a",
      "name": "Note: AI Data Prep"
    },
    {
      "parameters": {
        "content": "åš´æ ¼åœ°å€é©—è­‰ï¼š\nç¢ºä¿è·å“¡åƒ…åœ¨æœ‰æœ‰æ•ˆä½å€æ™‚æ‰è¢«æ’ç¨‹ã€‚ä¸å†é€€å›åˆ°æœå‹™åœ°å€ã€‚",
        "height": 100,
        "width": 250
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        19312,
        12272
      ],
      "id": "7c903b4c-406d-4430-8953-1620c40b0086",
      "name": "Note: Address Validation"
    },
    {
      "parameters": {
        "content": "ç³»çµ±æç¤ºè©èˆ‡ä¸Šä¸‹æ–‡ï¼š\n- å¤–éƒ¨åŒ–ç³»çµ±æç¤ºè©ä»¥ä¾¿ç·¨è¼¯ã€‚\n- åŒ…å«è·å“¡é€šå‹¤æ™‚é–“èˆ‡è·é›¢ã€‚",
        "height": 100,
        "width": 280
      },
      "type": "n8n-nodes-base.stickyNote",
      "typeVersion": 1,
      "position": [
        19056,
        12880
      ],
      "id": "7d3a6155-c3ac-4980-a342-5c30a6d240d2",
      "name": "Note: System Prompt"
    },
    {
      "parameters": {
        "jsCode": "// åˆä½µåœ°åœ–èˆ‡è·å“¡è³‡æ–™ - Code Node\n// Input 0: æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½ (staffList, freeSlotsCalendar, etc.)\n// Input 1: è·å“¡åœ°å€ (Google Maps API response)\n// âœ… FIX: Also get _mapsParams (including staffOrder) from æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸\n\nconst allInputs = $input.all();\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ========== é–‹å§‹åˆä½µ ==========');\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š Total inputs:', allInputs.length);\n\n// Get data from Input 0 (Staff Data)\nlet staffData = {};\ntry {\n  const input0 = $('æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½').first();\n  if (input0 && input0.json) {\n    staffData = input0.json;\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âœ… Input 0 (Staff): staffList length:', (staffData.staffList || []).length);\n  }\n} catch (e) {\n  console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âš ï¸ Cannot get Input 0:', String(e));\n  // Fallback: try first input\n  if (allInputs.length > 0 && allInputs[0].json) {\n    staffData = allInputs[0].json;\n  }\n}\n\n// Get data from Input 1 (Google Maps)\nlet mapsData = {};\ntry {\n  const input1 = $('è·å“¡åœ°å€').first();\n  if (input1 && input1.json) {\n    mapsData = input1.json;\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âœ… Input 1 (Maps): rows length:', (mapsData.rows || []).length);\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š origin_addresses:', (mapsData.origin_addresses || []).length);\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š destination_addresses:', (mapsData.destination_addresses || []).length);\n  }\n} catch (e) {\n  console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âš ï¸ Cannot get Input 1:', String(e));\n  // Fallback: try second input if available\n  if (allInputs.length > 1 && allInputs[1].json) {\n    mapsData = allInputs[1].json;\n  }\n}\n\n// âœ… FIX: Get _mapsParams (including staffOrder) from æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸\nlet mapsParams = {};\ntry {\n  const prepNode = $('æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸').first();\n  if (prepNode && prepNode.json && prepNode.json._mapsParams) {\n    mapsParams = prepNode.json._mapsParams;\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âœ… Got _mapsParams from æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸');\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š staffOrder length:', (mapsParams.staffOrder || []).length);\n    console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“‹ staffOrder:', (mapsParams.staffOrder || []).join(', '));\n  }\n} catch (e) {\n  console.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âš ï¸ Cannot get _mapsParams from æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸:', String(e));\n}\n\n// Merge both data sources\nconst merged = {\n  ...staffData,\n  // Google Maps specific fields\n  rows: mapsData.rows || [],\n  origin_addresses: mapsData.origin_addresses || [],\n  destination_addresses: mapsData.destination_addresses || [],\n  status: mapsData.status || null,\n  // âœ… FIX: Include _mapsParams with staffOrder\n  _mapsParams: mapsParams\n};\n\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] âœ… åˆä½µå®Œæˆ');\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š Final staffList:', (merged.staffList || []).length);\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š Final rows:', (merged.rows || []).length);\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ğŸ“Š Final _mapsParams.staffOrder:', (merged._mapsParams?.staffOrder || []).length);\nconsole.log('[åˆä½µåœ°åœ–èˆ‡è·å“¡] ========== åˆä½µçµæŸ ==========');\n\nreturn [{ json: merged }];"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18816,
        13056
      ],
      "id": "fa8c0357-b08d-4ced-bce2-073a39b8f120",
      "name": "åˆä½µåœ°åœ–èˆ‡è·å“¡è³‡æ–™"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        19152,
        12176
      ],
      "id": "708a880d-cbd0-49ea-a1b0-a89ec0046b7c",
      "name": "åˆä½µCRMè³‡æ–™1"
    },
    {
      "parameters": {
        "mode": "combine",
        "combinationMode": "mergeByPosition",
        "options": {}
      },
      "type": "n8n-nodes-base.merge",
      "typeVersion": 2.1,
      "position": [
        19248,
        12304
      ],
      "id": "310a5d36-11f3-479c-b583-5a483de08208",
      "name": "åˆä½µServiceè¨­å®š"
    },
    {
      "parameters": {
        "jsCode": "// Enhanced AI output parser with JSON repair\nconst items = $input.all();\nif (!items || items.length === 0) {\n  return [{\n    json: {\n      success: false,\n      error: 'No input data received',\n      recommendations: [],\n      formattedText: 'âŒ éŒ¯èª¤ï¼šç„¡è¼¸å…¥è³‡æ–™'\n    }\n  }];\n}\n\nconst now = new Date();\nconst hkNow = new Date(now.getTime() + 8 * 60 * 60000 - now.getTimezoneOffset() * 60000);\nconst currentDate = hkNow.toISOString().split('T')[0];\n\n// Helper: Clean and repair JSON from AI\nfunction repairJSON(text) {\n  if (!text) return text;\n  let cleaned = text.trim();\n\n  // Remove markdown code fences\n  if (cleaned.startsWith('```')) {\n    cleaned = cleaned.split('\\n').slice(1).join('\\n');\n  }\n  if (cleaned.endsWith('```')) {\n    cleaned = cleaned.split('\\n').slice(0, -1).join('\\n');\n  }\n\n  // Remove \"json\" language identifier\n  cleaned = cleaned.replace(/^json\\s*\\n/i, '');\n\n  // âœ… Fix trailing commas (common AI error)\n  // Remove commas before closing braces/brackets\n  cleaned = cleaned.replace(/,\\s*([}\\]])/g, '$1');\n\n  // Fix other common issues\n  cleaned = cleaned.replace(/\\bNaN\\b/g, 'null');\n  cleaned = cleaned.replace(/\\bundefined\\b/g, 'null');\n\n  return cleaned.trim();\n}\n\n// Parse AI output\nlet parsed;\nconst rawOutput = items[0].json.output || '';\n\ntry {\n  const cleaned = repairJSON(rawOutput);\n  parsed = JSON.parse(cleaned);\n\n  console.log('[è§£æAIè¼¸å‡º] âœ… JSON è§£ææˆåŠŸ');\n\n  // Validate and fix dates\n  if (parsed.recommendations && Array.isArray(parsed.recommendations)) {\n    for (const rec of parsed.recommendations) {\n      const recDate = rec.date || '';\n      const year = parseInt(recDate.substring(0, 4) || \"0\");\n\n      // Fix invalid dates\n      if (!recDate || recDate < currentDate || year < 2025) {\n        const tomorrow = new Date(hkNow.getTime() + 24 * 60 * 60000);\n        rec.date = tomorrow.toISOString().split('T')[0];\n        rec.reasons = rec.reasons || [];\n        rec.reasons.unshift(\"âš ï¸ æ—¥æœŸå·²èª¿æ•´ (åŸ: \" + (recDate || 'æœªçŸ¥') + \")\");\n      }\n\n      // Ensure constraints is a valid object\n      if (!rec.constraints || typeof rec.constraints !== 'object') {\n        rec.constraints = {};\n      }\n\n      // Fix startTime/endTime format (AI sometimes returns full range)\n      if (rec.startTime && rec.startTime.includes('-')) {\n        const parts = rec.startTime.split('-');\n        rec.startTime = parts[0].trim();\n        if (!rec.endTime || rec.endTime === rec.startTime) {\n          rec.endTime = parts[1] ? parts[1].trim() : rec.startTime;\n        }\n      }\n      if (rec.endTime && rec.endTime.includes('-')) {\n        const parts = rec.endTime.split('-');\n        rec.endTime = parts[1] ? parts[1].trim() : parts[0].trim();\n      }\n    }\n  }\n} catch (e) {\n  console.log('[è§£æAIè¼¸å‡º] âŒ JSON è§£æå¤±æ•—:', String(e));\n  console.log('[è§£æAIè¼¸å‡º] åŸå§‹è¼¸å‡º:', rawOutput.substring(0, 500));\n\n  return [{\n    json: {\n      success: false,\n      error: String(e),\n      rawOutput: rawOutput,\n      recommendations: [],\n      formattedText: \"âŒ AI è¼¸å‡ºè§£æå¤±æ•—\\n\" + String(e)\n    }\n  }];\n}\n\n// Format recommendations\nconst recommendations = parsed.recommendations || [];\n\nif (recommendations.length === 0) {\n  return [{\n    json: {\n      success: true,\n      status: 'no_recommendations',\n      confirmationRequired: false,\n      disclaimer: 'AI ç„¡æ³•æ‰¾åˆ°åˆé©çš„æ’ç¨‹å»ºè­°',\n      recommendations: [],\n      formattedText: 'âš ï¸ æœªèƒ½æ‰¾åˆ°åˆé©çš„æ’ç¨‹å»ºè­°ï¼Œè«‹äººæ‰‹å®‰æ’ã€‚',\n      summary: {\n        totalRecommendations: 0,\n        avgQualityScore: 0,\n        requiresHumanApproval: false\n      }\n    }\n  }];\n}\n\n// Format text output\nconst formattedText = recommendations.map((rec, idx) => {\n  const reasons = (rec.reasons || []).map(r => \"  - \" + r).join('\\n');\n\n  // Simple constraint display\n  const constraints = rec.constraints || {};\n  const constraintTags = [];\n  if (constraints.isFirstJob) constraintTags.push('é¦–å–®');\n  if (constraints.isLastJob) constraintTags.push('å°¾å–®');\n  if (constraints.hasNoJobsToday) constraintTags.push('ç•¶å¤©ç„¡å·¥ä½œ');\n  if (constraints.isCleaningService) constraintTags.push('æ¸…æ½”');\n\n  return \"**å»ºè­°æ’ç¨‹ \" + (idx + 1) + \"**\\n\" +\n         \"- è·å“¡ï¼š\" + rec.staff + \"\\n\" +\n         \"- æ™‚é–“ï¼š\" + rec.date + \" \" + rec.startTime + \"â€“\" + rec.endTime + \"\\n\" +\n         \"- åˆ†æ•¸ï¼š\" + rec.qualityScore + \"/100\\n\" +\n         (reasons ? \"- åŸå› ï¼š\\n\" + reasons : \"- åŸå› ï¼šç„¡\") +\n         (constraintTags.length > 0 ? \"\\n- æ¨™è¨˜ï¼š\" + constraintTags.join(', ') : '');\n}).join('\\n---\\n');\n\nconst avgScore = recommendations.reduce((sum, r) => sum + (r.qualityScore || 0), 0) / recommendations.length;\n\nconsole.log('[è§£æAIè¼¸å‡º] âœ… æˆåŠŸè§£æ ' + recommendations.length + ' å€‹å»ºè­°');\nconsole.log('[è§£æAIè¼¸å‡º] ğŸ“Š å¹³å‡åˆ†æ•¸:', Math.round(avgScore * 10) / 10);\n\nreturn [{\n  json: {\n    success: true,\n    status: 'proposal',\n    confirmationRequired: true,\n    disclaimer: 'âœ… ä»¥ä¸‹ç‚º AI æ’ç¨‹å»ºè­°ï¼Œå‹™å¿…ç”±ä¸»ç®¡ç¢ºèªå¾Œæ‰å¯åŸ·è¡Œã€‚',\n    recommendations,\n    formattedText,\n    summary: {\n      totalRecommendations: recommendations.length,\n      avgQualityScore: Math.round(avgScore * 10) / 10,\n      highestScore: Math.max(...recommendations.map(r => r.qualityScore || 0)),\n      requiresHumanApproval: true\n    },\n    meta: parsed.meta || {}\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        19792,
        13008
      ],
      "id": "a10b9213-eeca-48bd-a1a2-a1935d8f46aa",
      "name": "è§£æä¸¦æ ¼å¼åŒ–AIè¼¸å‡º"
    },
    {
      "parameters": {
        "jsCode": "// Step 1: Build Service Config Map, Extract Request Info, and Build CapabilityMap\n// âœ… UPDATED v2: Added all 5 Filters\n// - Filter 1: é ­å–®8åˆ†é˜è¦é™ (passed to step 3)\n// - Filter 2: å–®èˆ‡å–®15åˆ†é˜+30åˆ†é˜ç·©è¡ (passed to step 3)\n// - Filter 3: éœ§åŒ–é …ç›®15:00å‰ (enhanced detection)\n// - Filter 4: æ·±å±¤æ¸…æ½”éœ€ç›£å·¥ vs ä¸€èˆ¬æ¸…æ½”ä¸éœ€ç›£å·¥\n// - Filter 5: æ—©ä¸Šæ¸…æ½”ç„¡é™åˆ¶ + è£æ¸…éœ€æ—©é–‹å§‹\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json;\n\n  // Extract Request Info\n  const serviceType = json['æœå‹™'] || json['æœå‹™é …ç›®'] || '';\n  const duration = Number(json['é ä¼°æœå‹™æ™‚é–“(åˆ†é˜)']) || 60;\n  const serviceLocation = json['åœ°å€'] || json['district'] || '';\n\n  console.log('[1ï¸âƒ£ å»ºç«‹é…ç½®] ========== é–‹å§‹è™•ç† ==========');\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] æœå‹™é¡å‹: ${serviceType}`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] æœå‹™åœ°é»: ${serviceLocation}`);\n\n  // ========================================\n  // Filter 4: Helper functions for supervisor classification\n  // ========================================\n  function requiresSupervisor(serviceName) {\n    const supervisorPatterns = [\n      /è£ä¿®å¾Œæ¸…æ½”|è£æ¸…/i,\n      /å…¥ä¼™å‰æ¸…æ½”|å…¥æ¸…/i,\n      /å‰å±‹æ¸…æ½”|å‰æ¸…/i,\n      /æ·±å±¤æ¸…æ½”|æ·±æ¸…/i\n    ];\n    return supervisorPatterns.some(pattern => pattern.test(serviceName));\n  }\n\n  function isGeneralCleaning(serviceName) {\n    // ã€Œæ¸…ğŸ§¹ã€æˆ–ã€Œæ¸…ã€å–®å­— = ä¸€èˆ¬å®¶å±…æ¸…æ½”ï¼Œä¸éœ€ç›£å·¥\n    return /^æ¸…[ğŸ§¹]?$|^ä¸€èˆ¬.*æ¸…æ½”$|^å®¶å±….*æ¸…æ½”$/i.test(serviceName);\n  }\n\n  // ========================================\n  // Filter 3 & 5: Service time restrictions\n  // ========================================\n  function needsEarlyStart(serviceName) {\n    // éœ€è¦æ—©é–‹å§‹çš„æœå‹™ï¼ˆè£ä¿®å¾Œæ¸…æ½”éœ€è¦ä¹¾ç‡¥æ™‚é–“ç­‰ï¼‰\n    return /è£ä¿®å¾Œæ¸…æ½”|è£æ¸…|é™¤ç”²é†›|ç”²A|ç”²B|ç”²C/i.test(serviceName);\n  }\n\n  function isFoggingService(serviceName) {\n    // éœ§åŒ–/ç…™éœ§æœå‹™éœ€è¦15:00å‰\n    return /éœ§åŒ–|ç…™éœ§|ULV|å™´éœ§/i.test(serviceName);\n  }\n\n  function isBedBugService(serviceName) {\n    return /åºŠè¨/i.test(serviceName);\n  }\n\n  // ========================================\n  // Build Service Config Map\n  // ========================================\n  const serviceConfigMap = {};\n\n  if (json.serviceSheet && Array.isArray(json.serviceSheet)) {\n    console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸ“Š ä½¿ç”¨ serviceSheet (å…± ${json.serviceSheet.length} ç­†)`);\n    \n    for (const row of json.serviceSheet) {\n      if (!row) continue;\n      const key = String(row[\"æœå‹™ç°¡ç¨±1\"] || row[\"æœå‹™é …ç›®\"] || \"\").trim();\n      if (!key) continue;\n\n      // âœ… Filter 5 (UPDATED): æ—©ä¸Šæ¸…æ½” = Y è¡¨ç¤ºé€™æœå‹™åªèƒ½åœ¨æ—©ä¸Š 09:00-11:00 é€²è¡Œ (HARD FILTER)\n      const morningCleaningValue = String(row[\"æ—©ä¸Šæ¸…æ½”\"] || \"\").trim();\n      const isMorningOnlyRequired = /^Y$/i.test(morningCleaningValue);\n\n      // âœ… Filter 4: ç›£å·¥éœ€æ±‚åˆ†é¡\n      const needsSupervisor = requiresSupervisor(key);\n      const isGeneral = isGeneralCleaning(key);\n\n      // âœ… Filter 5: éœ€è¦æ—©é–‹å§‹çš„æœå‹™\n      const mustStartEarly = needsEarlyStart(key);\n\n      // âœ… Filter 3: éœ§åŒ–/åºŠè¨æœå‹™\n      const isFogging = isFoggingService(key);\n      const isBedBug = isBedBugService(key);\n\n\n\n      // âœ… Alias keys: allow matching by full name and any short name columns\n      const aliasKeys = [\n        key,\n        row[\"æœå‹™é …ç›®\"],\n        row[\"æœå‹™ç°¡ç¨±1\"],\n        row[\"æœå‹™ç°¡ç¨±2\"],\n        row[\"æœå‹™ç°¡ç¨±3\"],\n        row[\"æœå‹™ç°¡ç¨±4\"],\n      ]\n        .filter(v => v != null)\n        .map(v => String(v).trim())\n        .filter(Boolean);\n      serviceConfigMap[key] = {\n        // âœ… Filter 5 (UPDATED): æ—©ä¸Šæ¸…æ½” = Y â†’ æœå‹™åªèƒ½åœ¨ 09:00-11:00 é€²è¡Œ\n        morning_only_required: isMorningOnlyRequired,\n        morning_only_start: isMorningOnlyRequired ? '09:00' : null,\n        morning_only_end: isMorningOnlyRequired ? '11:00' : null,\n        is_morning_cleaning_service: false,  // æ£„ç”¨èˆŠé‚è¼¯\n        \n        // âœ… Filter 5: è£ä¿®å¾Œæ¸…æ½”ç­‰éœ€è¦æ—©é–‹å§‹ (14:00å‰)\n        must_start_early: mustStartEarly,\n        max_start_time: mustStartEarly ? '12:00' : null,\n        early_start_reason: mustStartEarly ? 'éœ€è¦ä¹¾ç‡¥/è™•ç†æ™‚é–“' : null,\n        \n        // âœ… Filter 3: éœ§åŒ–/åºŠè¨æœå‹™ (15:00å‰)\n        is_fogging_service: isFogging,\n        is_bedbug_service: isBedBug,\n        requires_before_1500: isFogging || isBedBug,\n        \n        // âœ… Filter 4: ç›£å·¥éœ€æ±‚\n        requires_supervisor: needsSupervisor,\n        requires_initial_visit: needsSupervisor,\n        requires_revisit: needsSupervisor,\n        is_general_cleaning: isGeneral,\n        \n        // ğŸš« æ£„ç”¨èˆŠé‚è¼¯\n        morning_cleaning_only: false  // ä¸å†ä½¿ç”¨æ­¤æ¬„ä½\n      };\n\n      // Index config under all alias keys\n      for (const alias of aliasKeys) {\n        serviceConfigMap[alias] = serviceConfigMap[key];\n      }\n\n      // Also index under whitespace-normalized alias keys (for inputs like \"å…¥ä¼™å‰ æ¸…æ½”æœå‹™\")\n      for (const alias of aliasKeys) {\n        const normalizedAlias = alias.replace(/\\s+/g, '');\n        if (normalizedAlias && !serviceConfigMap[normalizedAlias]) {\n          serviceConfigMap[normalizedAlias] = serviceConfigMap[key];\n        }\n      }\n\n      // è©³ç´°æ—¥èªŒ\n      if (isMorningOnlyRequired) {\n        console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸŒ… ${key}: æ—©ä¸Šæ¸…æ½”æœå‹™ (åªèƒ½åœ¨ 09:00-11:00 é€²è¡Œ)`);\n      }\n      if (mustStartEarly) {\n        console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] âš ï¸ ${key}: éœ€æ—©é–‹å§‹ (14:00å‰)`);\n      }\n      if (isFogging || isBedBug) {\n        console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸ• ${key}: éœ§åŒ–/åºŠè¨æœå‹™ (15:00å‰)`);\n      }\n      if (needsSupervisor) {\n        console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸ‘· ${key}: éœ€è¦ç›£å·¥åˆè¨ªåŠå›è¨ª`);\n      }\n      if (isGeneral) {\n        console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸ§¹ ${key}: ä¸€èˆ¬æ¸…æ½” (ä¸éœ€ç›£å·¥)`);\n      }\n    }\n  } else {\n    console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] âš ï¸ æ²’æœ‰ serviceSheet è³‡æ–™ï¼Œä½¿ç”¨æœå‹™åç¨±æ¨æ–·`);\n  }\n\n  // ========================================\n  // Apply config to current service type\n  // ========================================\n  const normalizedServiceType = String(serviceType || '').replace(/\\s+/g, '').trim();\n  \n  // å¦‚æœç•¶å‰æœå‹™ä¸åœ¨ serviceSheet ä¸­ï¼Œæ ¹æ“šåç¨±æ¨æ–·\n  if (!serviceConfigMap[normalizedServiceType] && !serviceConfigMap[serviceType]) {\n    const needsSupervisor = requiresSupervisor(serviceType);\n    const isGeneral = isGeneralCleaning(serviceType);\n    const mustStartEarly = needsEarlyStart(serviceType);\n    const isFogging = isFoggingService(serviceType);\n    const isBedBug = isBedBugService(serviceType);\n    \n    const inferredConfig = {\n      morning_only_required: false,\n      morning_only_start: null,\n      morning_only_end: null,\n      is_morning_cleaning_service: false,\n      must_start_early: mustStartEarly,\n      max_start_time: mustStartEarly ? '12:00' : (isFogging || isBedBug ? '15:00' : null),\n      early_start_reason: mustStartEarly ? 'éœ€è¦ä¹¾ç‡¥/è™•ç†æ™‚é–“' : null,\n      is_fogging_service: isFogging,\n      is_bedbug_service: isBedBug,\n      requires_before_1500: isFogging || isBedBug,\n      requires_supervisor: needsSupervisor,\n      requires_initial_visit: needsSupervisor,\n      requires_revisit: needsSupervisor,\n      is_general_cleaning: isGeneral,\n      morning_cleaning_only: false\n    };\n    \n    serviceConfigMap[normalizedServiceType] = inferredConfig;\n    serviceConfigMap[serviceType] = inferredConfig;\n    \n    console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸ” æ ¹æ“šåç¨±æ¨æ–·æœå‹™é…ç½®: ${serviceType}`);\n    if (needsSupervisor) console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - éœ€è¦ç›£å·¥: æ˜¯`);\n    if (mustStartEarly) console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - éœ€æ—©é–‹å§‹: æ˜¯ (14:00å‰)`);\n    if (isFogging || isBedBug) console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - éœ§åŒ–/åºŠè¨: æ˜¯ (15:00å‰)`);\n  }\n\n  // ========================================\n  // Build Staff Capability Map from staffSheet\n  // ========================================\n  const capabilityMap = {};\n  const supervisorList = [];  // âœ… Filter 4: Track supervisors\n  const staffSheet = json.staffSheet || [];\n\n  if (Array.isArray(staffSheet)) {\n    for (const row of staffSheet) {\n      if (!row || typeof row !== 'object') continue;\n      const name = (row[\"è·å“¡\"] || row[\"name\"] || row[\"Name\"] || '').trim();\n      if (!name) continue;\n\n      // Get capability from \"å¯æ‰¿æ¥å–®é¡å‹(æŠ€èƒ½)\" field\n      const capabilityStr = String(\n        row[\"å¯æ‰¿æ¥å–®é¡å‹(æŠ€èƒ½)\"] ||\n        row[\"å¯æ‰¿æ¥å–®é¡å‹\"] ||\n        row[\"skills\"] ||\n        ''\n      ).trim();\n\n      if (capabilityStr) {\n        const capabilities = capabilityStr\n          .split(',')\n          .map(s => s.trim())\n          .filter(s => s.length > 0);\n        capabilityMap[name] = capabilities;\n        \n        // âœ… Filter 4: Check if this staff is a supervisor\n        const isSupervisor = capabilities.some(cap => \n          /ç›£å·¥|ä¸»ç®¡|Supervisor|åˆè¨ª|å›è¨ª/i.test(cap)\n        );\n        if (isSupervisor) {\n          supervisorList.push(name);\n        }\n      } else {\n        capabilityMap[name] = [];\n      }\n    }\n  }\n\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] æœå‹™é…ç½®æ•¸é‡: ${Object.keys(serviceConfigMap).length}`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] è·å“¡èƒ½åŠ›æ˜ å°„: ${Object.keys(capabilityMap).length}ä½è·å“¡`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ç›£å·¥è·å“¡æ•¸é‡: ${supervisorList.length}ä½`);\n\n  // ========================================\n  // Output\n  // ========================================\n  const currentServiceConfig = serviceConfigMap[normalizedServiceType] || serviceConfigMap[serviceType] || {};\n  \n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®] ğŸ“‹ ç•¶å‰æœå‹™ã€Œ${serviceType}ã€çš„é…ç½®:`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - éœ€è¦ç›£å·¥: ${currentServiceConfig.requires_supervisor || false}`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - ä¸€èˆ¬æ¸…æ½”: ${currentServiceConfig.is_general_cleaning || false}`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - æ—©ä¸Šæ¸…æ½”(09:00-11:00): ${currentServiceConfig.morning_only_required || false}`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - éœ€æ—©é–‹å§‹: ${currentServiceConfig.must_start_early || false}`);\n  console.log(`[1ï¸âƒ£ å»ºç«‹é…ç½®]    - éœ§åŒ–/åºŠè¨(15:00å‰): ${currentServiceConfig.requires_before_1500 || false}`);\n  console.log('[1ï¸âƒ£ å»ºç«‹é…ç½®] ========== è™•ç†å®Œæˆ ==========');\n\n  results.push({\n    json: {\n      ...json,\n      serviceType,\n      duration,\n      serviceLocation,\n      serviceConfigMap,\n      normalizedServiceType,\n      capabilityMap,\n      supervisorList,\n      currentServiceConfig  // âœ… Pass current service config for easy access\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18400,
        13344
      ],
      "id": "fad750f8-9b4e-4b08-8df0-9d5b361a1a40",
      "name": "1ï¸âƒ£ å»ºç«‹é…ç½®æ˜ å°„"
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n\n// Step 2: Build Staff History Index\n\nconst CONFIG = {\n  MAX_CLEANING_PER_DAY: 2,\n};\n\nconst Helpers = {\n  toMin: (timeStr) => {\n    if (!timeStr) return null;\n    const [h, m] = String(timeStr).split(':').map(Number);\n    return h * 60 + m;\n  },\n\n  fromMin: (minutes) => {\n    const h = Math.floor(minutes / 60).toString().padStart(2, '0');\n    const m = (minutes % 60).toString().padStart(2, '0');\n    return `${h}:${m}`;\n  },\n};\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json || {};\n  const machineData = json.machineData || [];\n  const staffCommute = json.staffCommute || [];\n  const serviceType = json.serviceType || '';\n\n  console.log('[å»ºç«‹ç´¢å¼•] ========== é–‹å§‹è™•ç† ==========');\n\n  // Build Commute Map\n  const commuteMap = {};\n  for (const c of staffCommute) {\n    if (!c || !c.name) continue;\n    commuteMap[c.name] = c.travelMinutes != null ? c.travelMinutes : null;  // âœ… Keep null if no data\n  }\n\n  // âœ… DEBUG: Show commuteMap values\n  console.log(`[å»ºç«‹ç´¢å¼•] ğŸ“Š commuteMap è·å“¡æ•¸: ${Object.keys(commuteMap).length}`);\n  for (const [name, minutes] of Object.entries(commuteMap)) {\n    if (minutes !== null) {\n      console.log(`[å»ºç«‹ç´¢å¼•]   âœ… ${name}: ${minutes} åˆ†é˜`);\n    } else {\n      console.log(`[å»ºç«‹ç´¢å¼•]   âš ï¸ ${name}: ç„¡é€šå‹¤æ•¸æ“š`);\n    }\n  }\n\n  // Build History By Staff Date\n  const historyByStaffDate = {};\n\n  for (const apt of machineData) {\n    if (!apt) continue;\n\n    const staffName = String(apt.staff || '').trim();\n    const names = staffName\n      .split(/[+ï¼‹]/)\n      .map((s) => s.trim())\n      .filter(Boolean);\n\n    let dateStr = apt.date || (apt.start_at ? apt.start_at.split('T')[0] : null);\n    if (!dateStr) continue;\n\n    let startMin = null;\n    let endMin = null;\n\n    if (apt.start_at && apt.end_at) {\n      startMin = Helpers.toMin(apt.start_at.substring(11, 16));\n      endMin = Helpers.toMin(apt.end_at.substring(11, 16));\n    } else if (apt.start_time && apt.end_time) {\n      startMin = Helpers.toMin(apt.start_time);\n      endMin = Helpers.toMin(apt.end_time);\n    }\n\n    for (const name of names) {\n      if (!historyByStaffDate[name]) historyByStaffDate[name] = {};\n      if (!historyByStaffDate[name][dateStr]) historyByStaffDate[name][dateStr] = [];\n\n      historyByStaffDate[name][dateStr].push({\n        ...apt,\n        _startMin: startMin,\n        _endMin: endMin,\n        _isLeave:\n          (apt.job_type && String(apt.job_type).toLowerCase() === 'leave') ||\n          (apt.title && String(apt.title).includes('è«‹å‡')),\n      });\n    }\n  }\n\n  console.log(`[å»ºç«‹ç´¢å¼•] ğŸ“Š historyByStaffDate è·å“¡æ•¸: ${Object.keys(historyByStaffDate).length}`);\n  console.log('[å»ºç«‹ç´¢å¼•] ========== è™•ç†å®Œæˆ ==========');\n\n  results.push({\n    json: {\n      ...json,\n      historyByStaffDate,\n      commuteMap,\n      isCleaningRequest: /æ¸…æ½”|æ¸…[ğŸ§¹]?$|è£æ¸…|å…¥æ¸…|å‰æ¸…|æ·±æ¸…|Clean/i.test(serviceType),\n    },\n  });\n}\n\n// n8n requires an array of items: [{ json: {...} }, ...]\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18800,
        13232
      ],
      "id": "f4e029a0-c58e-4159-9b41-23690ee25c40",
      "name": "2ï¸âƒ£ å»ºç«‹è·å“¡æ­·å²ç´¢å¼•"
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// Step 3: Generate Candidates with All Filters\n// âœ… UPDATED v4: Filter 1 é ­å–®é€šå‹¤è¦å‰‡æ›´æ–°\n// - Filter 1: é ­å–®é€šå‹¤â‰¤8åˆ†é˜å¯æ­£å¸¸æ’ç¨‹ï¼Œ>8åˆ†é˜å‰‡å»¶å¾Œ3å°æ™‚\n// - Filter 2: å–®èˆ‡å–®15åˆ†é˜+30åˆ†é˜ç·©è¡\n// - Filter 3: éœ§åŒ–/åºŠè¨15:00å‰\n// - Filter 4: ç›£å·¥éœ€æ±‚ (handled in ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›)\n// - Filter 5: æ—©ä¸Šæ¸…æ½”ç„¡é™åˆ¶ + è£æ¸…éœ€æ—©é–‹å§‹\n\nconst CONFIG = {\n  MAX_CLEANING_PER_DAY: 2,\n  FIRST_JOB_COMMUTE_THRESHOLD: 15,  // âœ… é ­å–®é€šå‹¤æ™‚é–“ä¸Šé™ï¼ˆåˆ†é˜ï¼‰- 15åˆ†é˜å…§ä¸æ‰£åˆ†\n  FIRST_JOB_DELAY_HOURS: 3,        // âœ… è¶…éé€šå‹¤ä¸Šé™æ™‚ï¼Œå»¶å¾Œå¹¾å°æ™‚\n  JOB_TO_JOB_BUFFER: 30,           // Filter 2: å–®èˆ‡å–®ç·©è¡30åˆ†é˜\n  DEFAULT_TRAVEL_TIME: 15,         // Filter 2: é è¨­è¡Œè»Šæ™‚é–“15åˆ†é˜\n  // âœ… NEW: æ¸…æ½”æœå‹™æ—©ä¸Šæ™‚æ®µåå¥½ (Filter 6)\n  CLEANING_MORNING_CUTOFF: 720,    // 12:00 = 720 minutes, æ¸…æ½”æœå‹™å„ªå…ˆæ—©ä¸Š\n  SCORES: {\n    BASE: 100,\n    // Skill penalties\n    SKILL_PARTIAL: -100,\n    SKILL_NONE: -200,\n    // Commute penalties (Filter 1)\n    COMMUTE_9_15MIN: -50,\n    COMMUTE_16_30MIN: -75,\n    COMMUTE_OVER_30MIN: -100,\n    COMMUTE_NO_DATA: -30,\n    // Job gap penalties (Filter 2)\n    GAP_SHORT_1_15MIN: 0,          // âœ… 15åˆ†é˜å…§ä¸æ‰£åˆ†\n    GAP_SHORT_16_30MIN: -100,\n    GAP_SHORT_OVER_30MIN: -200,\n    // Timing penalties (Filter 3)\n    FOGGING_15_16: -100,\n    FOGGING_16_17: -150,\n    FOGGING_AFTER_17: -200,\n    // Revisit overflow penalties (NEW)\n    REVISIT_OVERFLOW_1_30MIN: -100,\n    REVISIT_OVERFLOW_31_60MIN: -150,\n    REVISIT_OVERFLOW_OVER_60MIN: -200,\n    // Cleaning job penalties (Filter 4)\n    CLEANING_2ND_JOB: -30,\n    CLEANING_3RD_JOB: -150,\n    // Morning cleaning penalties (Filter 5)\n    MORNING_LATE_1_30MIN: -75,\n    MORNING_LATE_31_60MIN: -125,\n    MORNING_LATE_OVER_60MIN: -200,\n    // âœ… NEW: æ¸…æ½”æœå‹™æ—©ä¸Šæ™‚æ®µåå¥½ (Filter 6)\n    CLEANING_MORNING_BONUS: 50,     // æ—©ä¸Šæ™‚æ®µåŠ åˆ†\n    CLEANING_AFTERNOON_PENALTY: -30, // ä¸‹åˆæ™‚æ®µæ‰£åˆ†\n    CLEANING_EVENING_PENALTY: -80,   // å‚æ™šæ™‚æ®µæ‰£åˆ†\n    // Work hours violation\n    WORK_HOURS_VIOLATION: -200,\n    PREF_NEAR_HOME: 10,\n    PENALTY_FAR_HOME: -10,\n    PREF_NO_JOBS_TODAY: 30,\n  }\n};\n\n// Define Helpers locally\nconst Helpers = {\n  toMin: (timeStr) => {\n    if (!timeStr) return null;\n    const [h, m] = String(timeStr).split(':').map(Number);\n    return h * 60 + m;\n  },\n  fromMin: (minutes) => {\n    const h = Math.floor(minutes / 60).toString().padStart(2, '0');\n    const m = (minutes % 60).toString().padStart(2, '0');\n    return `${h}:${m}`;\n  }\n};\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json;\n  const freeSlotsCalendar = json.freeSlotsCalendar || [];\n  const historyByStaffDate = json.historyByStaffDate || {};\n  const commuteMap = json.commuteMap || {};\n  const serviceType = json.serviceType || '';\n  const duration = json.duration || 60;\n  const isCleaningRequest = json.isCleaningRequest;\n  const serviceConfigMap = json.serviceConfigMap || {};\n  const normalizedServiceType = json.normalizedServiceType || '';\n  const currentServiceConfig = json.currentServiceConfig || {};\n  const jobTravelMap = json.jobTravelMap || {};  // Filter 2\n  const serviceLocation = json.serviceLocation || json['åœ°å€'] || '';\n\n  console.log('[3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾] ========== é–‹å§‹è™•ç† ==========');\n  console.log(`[3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾] æœå‹™: ${serviceType}, æ™‚é•·: ${duration}åˆ†`);\n  console.log(`[3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾] æœå‹™é…ç½®:`, JSON.stringify(currentServiceConfig));\n\n  const filteredCalendar = freeSlotsCalendar.map(staffCal => {\n    const staffName = staffCal.staff;\n    const commuteMin = commuteMap[staffName] || 30;\n\n    const processedDays = staffCal.days.map(dayObj => {\n      const date = dayObj.date;\n      const dailyHistory = historyByStaffDate[staffName]?.[date] || [];\n\n      // Rule 1: Leave Check\n      const isLeave = dailyHistory.some(a => a._isLeave) || dayObj.holiday;\n      if (isLeave) {\n        return {\n          ...dayObj,\n          free_slots: [],\n          candidates: [],\n          status: 'blocked_leave',\n          reason: 'Staff on leave/holiday'\n        };\n      }\n\n      // Rule 2: Cleaning Limit - æ¸…æ½”å–®æ¯å¤©ä¸è¶…é2å–®\n      if (isCleaningRequest) {\n        const cleaningCount = dailyHistory.filter(apt => /æ¸…æ½”|æ¸…[ğŸ§¹]?$|è£æ¸…|å…¥æ¸…|å‰æ¸…|æ·±æ¸…|Clean/i.test(apt.service || apt.title || '')).length;\n        if (cleaningCount >= CONFIG.MAX_CLEANING_PER_DAY) {\n          console.log(`[3ï¸âƒ£ æ¸…æ½”é™åˆ¶] âŒ ${staffName} ${date}: å·²æœ‰ ${cleaningCount} å–®æ¸…æ½”å·¥ä½œï¼Œè¶…éä¸Šé™ ${CONFIG.MAX_CLEANING_PER_DAY}`);\n          return {\n            ...dayObj,\n            free_slots: [],\n            candidates: [],\n            status: 'blocked_limit',\n            reason: `æ¸…æ½”å·¥ä½œå·²é”ä¸Šé™ (${cleaningCount}/${CONFIG.MAX_CLEANING_PER_DAY})`\n          };\n        } else if (cleaningCount > 0) {\n          console.log(`[3ï¸âƒ£ æ¸…æ½”é™åˆ¶] âš ï¸ ${staffName} ${date}: å·²æœ‰ ${cleaningCount} å–®æ¸…æ½”å·¥ä½œï¼Œå¯å†æ¥ ${CONFIG.MAX_CLEANING_PER_DAY - cleaningCount} å–®`);\n        }\n      }\n\n      // Get work hours\n      const workStartTime = dayObj.work_start;\n      const workEndTime = dayObj.work_end;\n      const workStartMin = Helpers.toMin(workStartTime);\n      const workEndMin = Helpers.toMin(workEndTime);\n\n      // Generate Candidates\n      const candidates = [];\n      const availableSlots = dayObj.free_slots || [];\n      let totalSkipped = 0;\n      let skippedReasons = [];\n\n      // Filter 2: Get existing jobs for this staff on this date\n      const travelKey = `${staffName}|${date}`;\n      const existingJobs = jobTravelMap[travelKey] || [];\n\n      availableSlots.forEach(slot => {\n        const slotStart = Helpers.toMin(slot.start);\n        const slotEnd = Helpers.toMin(slot.end);\n        const slotDuration = slot.minutes;\n\n        if (slotDuration < duration) return;\n\n        // âœ… Generate multiple candidate start times (every 180 minutes = 3 hours) within the slot\n        const candidateStarts = [];\n        for (let startMin = slotStart; startMin + duration <= slotEnd; startMin += 180) {\n          candidateStarts.push(startMin);\n        }\n\n        // If no candidates fit, skip this slot\n        if (candidateStarts.length === 0) return;\n\n        // Process each candidate start time\n        candidateStarts.forEach(candidateStart => {\n          let candidateEnd = candidateStart + duration;\n\n        // Rule 0: Work Hours Validation\n        if (workStartMin !== null && workEndMin !== null) {\n          if (candidateStart < workStartMin) {\n            totalSkipped++;\n            skippedReasons.push(`æ—©æ–¼é–‹å·¥æ™‚é–“ ${workStartTime}`);\n            return;\n          }\n          if (candidateEnd > workEndMin) {\n            totalSkipped++;\n            skippedReasons.push(`æ™šæ–¼æ”¶å·¥æ™‚é–“ ${workEndTime}`);\n            return;\n          }\n        }\n\n        // ========================================\n        // âœ… Filter 3: éœ§åŒ–/åºŠè¨æœå‹™15:00å‰ (HARD FILTER)\n        // ========================================\n        // ========================================\n        // âœ… Filter 3 (Soft): Fogging/Bedbug Timing Penalty\n        // ========================================\n        if (currentServiceConfig.requires_before_1500 || currentServiceConfig.is_fogging_service || currentServiceConfig.is_bedbug_service) {\n          if (candidateStart >= 1020) {  // After 17:00\n            score += CONFIG.SCORES.FOGGING_AFTER_17;\n            reasons.push(`éœ§åŒ–/åºŠè¨å¤ªæ™š (${Helpers.fromMin(candidateStart)}ï¼Œ${CONFIG.SCORES.FOGGING_AFTER_17}åˆ†)`);\n            constraints.foggingAfter17 = true;\n            console.log(`[3ï¸âƒ£ Filter3] âš ï¸ ${staffName} ${date}: éœ§åŒ–/åºŠè¨ ${Helpers.fromMin(candidateStart)} > 17:00 â†’ ${CONFIG.SCORES.FOGGING_AFTER_17}åˆ†`);\n          } else if (candidateStart >= 960) {  // 16:01-17:00\n            score += CONFIG.SCORES.FOGGING_16_17;\n            reasons.push(`éœ§åŒ–/åºŠè¨è¼ƒæ™š (${Helpers.fromMin(candidateStart)}ï¼Œ${CONFIG.SCORES.FOGGING_16_17}åˆ†)`);\n            constraints.fogging16_17 = true;\n            console.log(`[3ï¸âƒ£ Filter3] âš ï¸ ${staffName} ${date}: éœ§åŒ–/åºŠè¨ ${Helpers.fromMin(candidateStart)} (16:01-17:00) â†’ ${CONFIG.SCORES.FOGGING_16_17}åˆ†`);\n          } else if (candidateStart >= 900) {  // 15:01-16:00\n            score += CONFIG.SCORES.FOGGING_15_16;\n            reasons.push(`éœ§åŒ–/åºŠè¨ç¨æ™š (${Helpers.fromMin(candidateStart)}ï¼Œ${CONFIG.SCORES.FOGGING_15_16}åˆ†)`);\n            constraints.fogging15_16 = true;\n            console.log(`[3ï¸âƒ£ Filter3] âš ï¸ ${staffName} ${date}: éœ§åŒ–/åºŠè¨ ${Helpers.fromMin(candidateStart)} (15:01-16:00) â†’ ${CONFIG.SCORES.FOGGING_15_16}åˆ†`);\n          } else {\n            console.log(`[3ï¸âƒ£ Filter3] âœ… ${staffName} ${date}: éœ§åŒ–/åºŠè¨ ${Helpers.fromMin(candidateStart)} â‰¤ 15:00 â†’ OK`);\n          }\n        }\n\n        // ========================================\n        // âœ… Filter 5 (UPDATED v2): æ—©ä¸Šæ¸…æ½”æœå‹™å¿…é ˆåœ¨ 09:00-11:00 é€²è¡Œ (HARD FILTER)\n        // - é–‹å§‹æ™‚é–“å¿…é ˆ >= 09:00 ä¸” < 11:00\n        // - çµæŸæ™‚é–“å¿…é ˆ <= 11:00\n        // ========================================\n        if (currentServiceConfig.morning_only_required) {\n          const morningStart = Helpers.toMin(currentServiceConfig.morning_only_start || '09:00');\n          const morningEnd = Helpers.toMin(currentServiceConfig.morning_only_end || '11:00');\n          \n          console.log(`[3ï¸âƒ£ Filter5] ğŸ” ${staffName} ${date}: æª¢æŸ¥æ—©ä¸Šæ¸…æ½”é™åˆ¶ - å€™é¸ ${Helpers.fromMin(candidateStart)}-${Helpers.fromMin(candidateEnd)}, å…è¨±ç¯„åœ ${Helpers.fromMin(morningStart)}-${Helpers.fromMin(morningEnd)}`);\n          \n          // HARD FILTER: Reject if candidate is outside 09:00-11:00\n          // âœ… FIXED: Added explicit check for candidateStart >= morningEnd (starts at or after 11:00)\n          if (candidateStart < morningStart || candidateStart >= morningEnd || candidateEnd > morningEnd) {\n            totalSkipped++;\n            const rejectReason = candidateStart < morningStart ? 'é–‹å§‹æ™‚é–“æ—©æ–¼09:00' : \n                                 candidateStart >= morningEnd ? 'é–‹å§‹æ™‚é–“æ™šæ–¼æˆ–ç­‰æ–¼11:00' : \n                                 'çµæŸæ™‚é–“æ™šæ–¼11:00';\n            skippedReasons.push(\n              `æ—©ä¸Šæ¸…æ½”æœå‹™å¿…é ˆåœ¨ ${currentServiceConfig.morning_only_start}-${currentServiceConfig.morning_only_end} é€²è¡Œ (${rejectReason}, å€™é¸: ${Helpers.fromMin(candidateStart)}-${Helpers.fromMin(candidateEnd)})`\n            );\n            console.log(`[3ï¸âƒ£ Filter5] âŒ ${staffName} ${date}: æ—©ä¸Šæ¸…æ½”æœå‹™ ${Helpers.fromMin(candidateStart)}-${Helpers.fromMin(candidateEnd)} è¶…å‡º 09:00-11:00 (${rejectReason}) â†’ è·³é`);\n            return;\n          }\n          console.log(`[3ï¸âƒ£ Filter5] âœ… ${staffName} ${date}: æ—©ä¸Šæ¸…æ½”æœå‹™ ${Helpers.fromMin(candidateStart)}-${Helpers.fromMin(candidateEnd)} åœ¨ 09:00-11:00 â†’ OK`);\n        }\n        else if (currentServiceConfig.must_start_early) {\n          const maxStartTime = currentServiceConfig.max_start_time || '12:00';\n          const maxStartMin = Helpers.toMin(maxStartTime);\n\n          if (candidateStart >= maxStartMin) {\n            totalSkipped++;\n            skippedReasons.push(\n              `${serviceType} å¿…é ˆåœ¨ ${maxStartTime} å‰é–‹å§‹ (å€™é¸: ${Helpers.fromMin(candidateStart)}) - ${currentServiceConfig.early_start_reason || 'éœ€è¦æ—©é–‹å§‹'}`\n            );\n            return;\n          }\n        }\n\n        // Find previous/next job\n        const sortedHistory = [...dailyHistory].sort((a,b) => (a._startMin || 0) - (b._startMin || 0));\n        const reversedHistory = [...sortedHistory].reverse();\n        const prevJob = reversedHistory.find(a => a._endMin && a._endMin <= candidateStart);\n        const nextJob = sortedHistory.find(a => a._startMin && a._startMin >= candidateEnd);\n\n        // Initialize scoring\n        let score = CONFIG.SCORES.BASE;\n        const reasons = [];\n        const constraints = {};\n\n        // âœ… NEW: Apply skill mismatch penalty\n        const staffMatchQuality = staffCal._skillMatchQuality || 'exact';\n        if (staffMatchQuality === 'partial') {\n          score -= 100;  // Deduct 100 points for partial skill match\n          reasons.push('âš ï¸ æŠ€èƒ½éƒ¨åˆ†åŒ¹é… (æ‰£100åˆ†)');\n          constraints.skillPartialMatch = true;\n          console.log(`[3ï¸âƒ£ Scoring] âš ï¸ ${staffName} ${date}: æŠ€èƒ½éƒ¨åˆ†åŒ¹é…ï¼Œæ‰£100åˆ†`);\n        } else if (staffMatchQuality === 'none') {\n          score -= 200;  // Deduct 200 points for no skill match\n          reasons.push('âŒ æŠ€èƒ½ä¸åŒ¹é… (æ‰£200åˆ†)');\n          constraints.skillNoMatch = true;\n          console.log(`[3ï¸âƒ£ Scoring] âŒ ${staffName} ${date}: æŠ€èƒ½ä¸åŒ¹é…ï¼Œæ‰£200åˆ†`);\n        } else if (staffMatchQuality === 'exact') {\n          // No penalty for exact match\n          console.log(`[3ï¸âƒ£ Scoring] âœ… ${staffName} ${date}: æŠ€èƒ½ç²¾ç¢ºåŒ¹é…`);\n        }\n\n        // ========================================\n        // âœ… NEW: Revisit Time Overflow Check\n        // ========================================\n        if (currentServiceConfig.requires_revisit) {\n          const revisitDelay = json.revisitDelay || json['å›è¨ªä¸­é–“ç©ºæª”(å°æ™‚)'] || 2;  // hours\n          const revisitDuration = json.revisitDuration || json['å›è¨ªåœç•™æ™‚é•·(åˆ†é˜)'] || 60;  // minutes\n\n          const revisitDelayMin = revisitDelay * 60;\n          const revisitStartMin = candidateEnd + revisitDelayMin;\n          const revisitEndMin = revisitStartMin + revisitDuration;\n\n          const workEndMin = staffCal.work_end ? Helpers.toMin(staffCal.work_end) : 22 * 60;  // default 22:00\n\n          if (revisitEndMin > workEndMin) {\n            const overflowMin = revisitEndMin - workEndMin;\n            let penalty = 0;\n            let reason = '';\n\n            if (overflowMin <= 30) {\n              penalty = CONFIG.SCORES.REVISIT_OVERFLOW_1_30MIN;\n              reason = `å›è¨ªè¶…æ™‚${overflowMin}åˆ† (${penalty}åˆ†)`;\n            } else if (overflowMin <= 60) {\n              penalty = CONFIG.SCORES.REVISIT_OVERFLOW_31_60MIN;\n              reason = `å›è¨ªè¶…æ™‚${overflowMin}åˆ† (${penalty}åˆ†)`;\n            } else {\n              penalty = CONFIG.SCORES.REVISIT_OVERFLOW_OVER_60MIN;\n              reason = `å›è¨ªè¶…æ™‚${overflowMin}åˆ† (${penalty}åˆ†)`;\n            }\n\n            score += penalty;\n            reasons.push(reason);\n            constraints.revisitOverflow = overflowMin;\n            console.log(`[3ï¸âƒ£ Revisit] âš ï¸ ${staffName} ${date}: å›è¨ªæœƒåœ¨ ${Helpers.fromMin(revisitEndMin)} çµæŸï¼Œè¶…éæ”¶å·¥æ™‚é–“ ${Helpers.fromMin(workEndMin)}ï¼Œæ‰£${-penalty}åˆ†`);\n          } else {\n            console.log(`[3ï¸âƒ£ Revisit] âœ… ${staffName} ${date}: å›è¨ªæ™‚é–“OK (çµæŸæ–¼ ${Helpers.fromMin(revisitEndMin)})`);\n          }\n        }\n\n        const isFirstJob = !prevJob;\n        const isLastJob = !nextJob;\n\n        if (isFirstJob) constraints.isFirstJob = true;\n        if (isLastJob) constraints.isLastJob = true;\n\n        // ========================================\n        // âœ… Filter 1: é ­å–®é€šå‹¤è¦é™ (SOFT FILTER for must_start_early services)\n        // é€šå‹¤ â‰¤ 8åˆ†é˜: å¯æ­£å¸¸æ’ç¨‹\n        // é€šå‹¤ > 8åˆ†é˜: \n        //   - ä¸€èˆ¬æœå‹™: å¿…é ˆåœ¨ã€Œé–‹å·¥æ™‚é–“ + é€šå‹¤æ™‚é–“ + 30åˆ†é˜ç·©è¡ã€å¾Œé–‹å§‹ (HARD)\n        //   - must_start_earlyæœå‹™: æ¸›åˆ†ä½†ä¸æ‹’çµ• (SOFT)\n        // ========================================\n        if (isFirstJob) {\n          const hasRealCommuteData = commuteMap[staffName] !== undefined && commuteMap[staffName] !== null;\n          const commuteBuffer = 30;  // 30åˆ†é˜ç·©è¡\n          const isSoftFilterMode = currentServiceConfig.must_start_early || currentServiceConfig.is_morning_cleaning_service;\n\n          if (hasRealCommuteData) {\n            if (commuteMin > CONFIG.FIRST_JOB_COMMUTE_THRESHOLD) {\n              // é€šå‹¤è¶…é8åˆ†é˜ï¼Œè¨ˆç®—æœ€æ—©é–‹å§‹æ™‚é–“\n              const earliestStartMin = workStartMin + commuteMin + commuteBuffer;\n\n              if (candidateStart < earliestStartMin) {\n                if (isSoftFilterMode) {\n                  // SOFT FILTER: æ¸›åˆ†ä½†ä¸æ‹’çµ•\n                  const penaltyMinutes = earliestStartMin - candidateStart;\n                  score -= Math.min(penaltyMinutes, 60);  // æœ€å¤šæ‰£60åˆ†\n                  reasons.push(`âš ï¸ é ­å–®é€šå‹¤è¼ƒé  (${commuteMin}åˆ†)ï¼Œå»ºè­° ${Helpers.fromMin(earliestStartMin)} å¾Œé–‹å§‹`);\n                  constraints.commuteWarning = true;\n                  console.log(`[3ï¸âƒ£ Filter1] âš ï¸ ${staffName} ${date}: é ­å–®é€šå‹¤ ${commuteMin}åˆ†ï¼Œå€™é¸ ${Helpers.fromMin(candidateStart)} < å»ºè­° ${Helpers.fromMin(earliestStartMin)} â†’ æ¸›åˆ† -${Math.min(penaltyMinutes, 60)}`);\n                } else {\n                  // HARD FILTER: æ‹’çµ•\n                  totalSkipped++;\n                  skippedReasons.push(\n                    `é ­å–®é€šå‹¤éé  (${commuteMin}åˆ† > ${CONFIG.FIRST_JOB_COMMUTE_THRESHOLD}åˆ†)ï¼Œå¿…é ˆåœ¨ ${Helpers.fromMin(earliestStartMin)} å¾Œé–‹å§‹ (å€™é¸: ${Helpers.fromMin(candidateStart)})`\n                  );\n                  console.log(`[3ï¸âƒ£ Filter1] âŒ ${staffName} ${date}: é ­å–®é€šå‹¤ ${commuteMin}åˆ† > ${CONFIG.FIRST_JOB_COMMUTE_THRESHOLD}åˆ†ï¼Œå€™é¸ ${Helpers.fromMin(candidateStart)} < æœ€æ—© ${Helpers.fromMin(earliestStartMin)} â†’ è·³é`);\n                  return;\n                }\n              } else {\n                // é€šéæª¢æŸ¥\n                reasons.push(`âœ… é ­å–®é€šå‹¤è¼ƒé  (${commuteMin}åˆ†)ï¼Œå·²åœ¨ ${Helpers.fromMin(earliestStartMin)} å¾Œé–‹å§‹`);\n                constraints.firstJobDelayed = true;\n                console.log(`[3ï¸âƒ£ Filter1] âœ… ${staffName} ${date}: é ­å–®é€šå‹¤ ${commuteMin}åˆ†ï¼Œå€™é¸ ${Helpers.fromMin(candidateStart)} â‰¥ ${Helpers.fromMin(earliestStartMin)} â†’ OK`);\n              }\n            } else {\n              // é€šå‹¤ â‰¤ 8åˆ†é˜ï¼Œå¯æ­£å¸¸æ’ç¨‹\n              reasons.push(`âœ… é ­å–®é€šå‹¤OK (${commuteMin}åˆ† â‰¤ ${CONFIG.FIRST_JOB_COMMUTE_THRESHOLD}åˆ†)`);\n              console.log(`[3ï¸âƒ£ Filter1] âœ… ${staffName} ${date}: é ­å–®é€šå‹¤ ${commuteMin}åˆ† â‰¤ ${CONFIG.FIRST_JOB_COMMUTE_THRESHOLD}åˆ† â†’ OK`);\n            }\n          } else {\n            // ç„¡é€šå‹¤æ•¸æ“šï¼Œé è¨­ä½¿ç”¨30åˆ†é˜ + ç·©è¡\n            const defaultCommuteMin = 30;\n            const earliestStartMin = workStartMin + defaultCommuteMin + commuteBuffer;\n\n            if (candidateStart < earliestStartMin) {\n              if (isSoftFilterMode) {\n                // SOFT FILTER: æ¸›åˆ†ä½†ä¸æ‹’çµ•\n                const penaltyMinutes = earliestStartMin - candidateStart;\n                score -= Math.min(penaltyMinutes, 40);  // ç„¡æ•¸æ“šæ™‚è¼ƒå°‘æ‰£åˆ†\n                reasons.push(`âš ï¸ é ­å–®ç„¡é€šå‹¤æ•¸æ“šï¼Œå»ºè­° ${Helpers.fromMin(earliestStartMin)} å¾Œé–‹å§‹`);\n                constraints.commuteWarning = true;\n                console.log(`[3ï¸âƒ£ Filter1] âš ï¸ ${staffName} ${date}: ç„¡é€šå‹¤æ•¸æ“šï¼Œå€™é¸ ${Helpers.fromMin(candidateStart)} < å»ºè­° ${Helpers.fromMin(earliestStartMin)} â†’ æ¸›åˆ† -${Math.min(penaltyMinutes, 40)}`);\n              } else {\n                // HARD FILTER: æ‹’çµ•\n                totalSkipped++;\n                skippedReasons.push(\n                  `é ­å–®ç„¡é€šå‹¤æ•¸æ“šï¼Œé è¨­å¿…é ˆåœ¨ ${Helpers.fromMin(earliestStartMin)} å¾Œé–‹å§‹ (å€™é¸: ${Helpers.fromMin(candidateStart)})`\n                );\n                console.log(`[3ï¸âƒ£ Filter1] âš ï¸ ${staffName} ${date}: ç„¡é€šå‹¤æ•¸æ“šï¼Œå€™é¸ ${Helpers.fromMin(candidateStart)} < æœ€æ—© ${Helpers.fromMin(earliestStartMin)} â†’ è·³é`);\n                return;\n              }\n            } else {\n              reasons.push(`âš ï¸ é ­å–® (ç„¡é€šå‹¤æ•¸æ“šï¼Œé è¨­å»¶å¾Œè‡³ ${Helpers.fromMin(earliestStartMin)} å¾Œ)`);\n              constraints.firstJobDelayed = true;\n              console.log(`[3ï¸âƒ£ Filter1] âš ï¸ ${staffName} ${date}: ç„¡é€šå‹¤æ•¸æ“šï¼Œå€™é¸ ${Helpers.fromMin(candidateStart)} â‰¥ ${Helpers.fromMin(earliestStartMin)} â†’ OK (é è¨­å»¶å¾Œ)`);\n            }\n          }\n        }\n\n        // ========================================\n        // Filter 2: å–®èˆ‡å–®15åˆ†é˜+30åˆ†é˜ç·©è¡ (HARD FILTER)\n        // ========================================\n        // ========================================\n        // âœ… Filter 2 (Soft): Job-to-Job Gap Penalty\n        // ========================================\n        if (existingJobs.length > 0) {\n          for (const job of existingJobs) {\n            const jobStartMin = job.startMin;\n            const jobEndMin = job.endMin;\n\n            if (jobStartMin === null || jobEndMin === null) continue;\n\n            // Case 1: æ–°å·¥ä½œåœ¨ç¾æœ‰å·¥ä½œä¹‹å‰\n            if (candidateEnd <= jobStartMin) {\n              const travelTime = job.prevTravel || CONFIG.DEFAULT_TRAVEL_TIME;\n              const requiredGap = travelTime + CONFIG.JOB_TO_JOB_BUFFER;\n              const actualGap = jobStartMin - candidateEnd;\n\n              if (actualGap < requiredGap) {\n                const shortage = requiredGap - actualGap;\n                let penalty = 0;\n\n                if (shortage <= 15) {\n                  penalty = CONFIG.SCORES.GAP_SHORT_1_15MIN;\n                } else if (shortage <= 30) {\n                  penalty = CONFIG.SCORES.GAP_SHORT_16_30MIN;\n                } else {\n                  penalty = CONFIG.SCORES.GAP_SHORT_OVER_30MIN;\n                }\n\n                score += penalty;\n                reasons.push(`èˆ‡ä¸‹ä¸€å–®é–“éš”ä¸è¶³ (ç¼º${shortage}åˆ†ï¼Œ${penalty}åˆ†)`);\n                constraints.gapShortageNext = shortage;\n                console.log(`[3ï¸âƒ£ Filter2] âš ï¸ ${staffName} ${date}: èˆ‡ä¸‹ä¸€å–®${Helpers.fromMin(jobStartMin)}é–“éš”${actualGap}åˆ† < éœ€${requiredGap}åˆ† (ç¼º${shortage}åˆ†) â†’ ${penalty}åˆ†`);\n              }\n            }\n\n            // Case 2: æ–°å·¥ä½œåœ¨ç¾æœ‰å·¥ä½œä¹‹å¾Œ\n            if (candidateStart >= jobEndMin) {\n              const travelTime = job.nextTravel || CONFIG.DEFAULT_TRAVEL_TIME;\n              const requiredGap = travelTime + CONFIG.JOB_TO_JOB_BUFFER;\n              const actualGap = candidateStart - jobEndMin;\n\n              if (actualGap < requiredGap) {\n                const shortage = requiredGap - actualGap;\n                let penalty = 0;\n\n                if (shortage <= 15) {\n                  penalty = CONFIG.SCORES.GAP_SHORT_1_15MIN;\n                } else if (shortage <= 30) {\n                  penalty = CONFIG.SCORES.GAP_SHORT_16_30MIN;\n                } else {\n                  penalty = CONFIG.SCORES.GAP_SHORT_OVER_30MIN;\n                }\n\n                score += penalty;\n                reasons.push(`èˆ‡å‰ä¸€å–®é–“éš”ä¸è¶³ (ç¼º${shortage}åˆ†ï¼Œ${penalty}åˆ†)`);\n                constraints.gapShortagePrev = shortage;\n                console.log(`[3ï¸âƒ£ Filter2] âš ï¸ ${staffName} ${date}: èˆ‡å‰ä¸€å–®${Helpers.fromMin(jobEndMin)}é–“éš”${actualGap}åˆ† < éœ€${requiredGap}åˆ† (ç¼º${shortage}åˆ†) â†’ ${penalty}åˆ†`);\n              }\n            }\n          }\n        }\n\n        // Rule 2.1: Fair Distribution\n        const hasNoJobsToday = dailyHistory.length === 0 || dayObj.booked_minutes === 0;\n        if (hasNoJobsToday) {\n          score += CONFIG.SCORES.PREF_NO_JOBS_TODAY;\n          reasons.push('å„ªå…ˆæ´¾å–®ï¼šç•¶å¤©ç„¡å·¥ä½œ');\n          constraints.hasNoJobsToday = true;\n        }\n\n        // Rule 3.1: Near Home Preference\n        if (isFirstJob || isLastJob) {\n          if (commuteMin <= 20) {\n            score += CONFIG.SCORES.PREF_NEAR_HOME;\n            reasons.push(`Near home (${commuteMin} min)`);\n          } else if (commuteMin > 45) {\n            score += CONFIG.SCORES.PENALTY_FAR_HOME;\n            reasons.push(`Far from home (${commuteMin} min)`);\n\n            if (commuteMin > 60 && candidateStart < 600) {\n              score += -30;\n              reasons.push(\"Early start at far location discouraged\");\n            }\n          }\n        }\n\n        // ========================================\n        // âœ… Filter 6: æ¸…æ½”æœå‹™æ—©ä¸Šæ™‚æ®µåå¥½\n        // æ¸…æ½”æœå‹™å„ªå…ˆå®‰æ’åœ¨æ—©ä¸Šï¼ˆ12:00å‰ï¼‰\n        // - 09:00-12:00: åŠ åˆ† (+50)\n        // - 12:00-15:00: è¼•å¾®æ‰£åˆ† (-30)\n        // - 15:00å¾Œ: è¼ƒå¤§æ‰£åˆ† (-80)\n        // ========================================\n        if (isCleaningRequest) {\n          if (candidateStart < CONFIG.CLEANING_MORNING_CUTOFF) {\n            // æ—©ä¸Šæ™‚æ®µ (12:00å‰) - åŠ åˆ†\n            score += CONFIG.SCORES.CLEANING_MORNING_BONUS;\n            reasons.push(`âœ… æ¸…æ½”æœå‹™æ—©ä¸Šæ™‚æ®µ (${Helpers.fromMin(candidateStart)}ï¼Œ+${CONFIG.SCORES.CLEANING_MORNING_BONUS}åˆ†)`);\n            constraints.cleaningMorningSlot = true;\n            console.log(`[3ï¸âƒ£ Filter6] âœ… ${staffName} ${date}: æ¸…æ½”æœå‹™ ${Helpers.fromMin(candidateStart)} < 12:00 â†’ +${CONFIG.SCORES.CLEANING_MORNING_BONUS}åˆ† (æ—©ä¸Šå„ªå…ˆ)`);\n          } else if (candidateStart < 900) {\n            // ä¸‹åˆæ™‚æ®µ (12:00-15:00) - è¼•å¾®æ‰£åˆ†\n            score += CONFIG.SCORES.CLEANING_AFTERNOON_PENALTY;\n            reasons.push(`âš ï¸ æ¸…æ½”æœå‹™ä¸‹åˆæ™‚æ®µ (${Helpers.fromMin(candidateStart)}ï¼Œ${CONFIG.SCORES.CLEANING_AFTERNOON_PENALTY}åˆ†)`);\n            constraints.cleaningAfternoonSlot = true;\n            console.log(`[3ï¸âƒ£ Filter6] âš ï¸ ${staffName} ${date}: æ¸…æ½”æœå‹™ ${Helpers.fromMin(candidateStart)} (12:00-15:00) â†’ ${CONFIG.SCORES.CLEANING_AFTERNOON_PENALTY}åˆ†`);\n          } else {\n            // å‚æ™šæ™‚æ®µ (15:00å¾Œ) - è¼ƒå¤§æ‰£åˆ†\n            score += CONFIG.SCORES.CLEANING_EVENING_PENALTY;\n            reasons.push(`âŒ æ¸…æ½”æœå‹™å‚æ™šæ™‚æ®µ (${Helpers.fromMin(candidateStart)}ï¼Œ${CONFIG.SCORES.CLEANING_EVENING_PENALTY}åˆ†)`);\n            constraints.cleaningEveningSlot = true;\n            console.log(`[3ï¸âƒ£ Filter6] âŒ ${staffName} ${date}: æ¸…æ½”æœå‹™ ${Helpers.fromMin(candidateStart)} > 15:00 â†’ ${CONFIG.SCORES.CLEANING_EVENING_PENALTY}åˆ†`);\n          }\n        }\n\n        candidates.push({\n          start: Helpers.fromMin(candidateStart),\n          end: Helpers.fromMin(candidateEnd),\n          qualityScore: score,\n          reasons: reasons,\n          constraints: constraints\n        });\n        });  // âœ… Close candidateStarts.forEach\n      });\n\n      return {\n        ...dayObj,\n        candidates,\n        hasCandidates: candidates.length > 0,\n        _filterStats: {\n          totalSkipped,\n          skippedReasons\n        }\n      };\n    });\n\n    return {\n      ...staffCal,\n      days: processedDays\n    };\n  });\n\n  // Count total candidates\n  let totalCandidates = 0;\n  let totalSkipped = 0;\n  filteredCalendar.forEach(s => {\n    s.days.forEach(d => {\n      totalCandidates += (d.candidates || []).length;\n      totalSkipped += d._filterStats?.totalSkipped || 0;\n    });\n  });\n\n  console.log(`[3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾] è™•ç†å®Œæˆ: ${filteredCalendar.length} ä½è·å“¡`);\n  console.log(`[3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾] ç¸½å€™é¸æ•¸: ${totalCandidates}, è·³éæ•¸: ${totalSkipped}`);\n  console.log('[3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾] ========== è™•ç†å®Œæˆ ==========');\n\n  results.push({\n    json: {\n      ...json,\n      filteredSlotsCalendar: filteredCalendar\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18752,
        13760
      ],
      "id": "e555352c-3a26-4ede-b356-6d866d4d4912",
      "name": "3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾å€™é¸æ™‚æ®µ"
    },
    {
      "parameters": {
        "jsCode": "// @ts-nocheck\n// Step 4: Flatten and Limit Candidates (Max 2 per staff per day, then top 20 overall)\n// SORT BY DATE FIRST (earliest to latest)\nconst MAX_SLOTS_PER_STAFF_PER_DAY = 2;\nconst TOP_N_CANDIDATES = 20;  // âœ… Return 20 results\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json;\n  const filteredCalendar = json.filteredSlotsCalendar || [];\n\n  console.log('[4ï¸âƒ£ é™åˆ¶] ========== START ==========');\n  console.log('[4ï¸âƒ£ é™åˆ¶] ğŸ“Š Items received:', items.length);\n  if (items.length > 0 && items[0].json) {\n    const json = items[0].json;\n    console.log('[4ï¸âƒ£ é™åˆ¶] ğŸ“Š filteredSlotsCalendar exists:', !!json.filteredSlotsCalendar);\n    if (json.filteredSlotsCalendar) {\n      console.log('[4ï¸âƒ£ é™åˆ¶] ğŸ“Š Staff count:', json.filteredSlotsCalendar.length);\n      let totalDays = 0;\n      let totalCandidates = 0;\n      json.filteredSlotsCalendar.forEach(s => {\n        totalDays += s.days.length;\n        s.days.forEach(d => {\n          if (d.candidates) totalCandidates += d.candidates.length;\n        });\n      });\n      console.log('[4ï¸âƒ£ é™åˆ¶] ğŸ“Š Total days:', totalDays);\n      console.log('[4ï¸âƒ£ é™åˆ¶] ğŸ“Š Total candidates before flatten:', totalCandidates);\n    }\n  }\n\n  // Flatten all candidates\n  const allCandidates = [];\n  for (const staffCal of filteredCalendar) {\n    const staffName = staffCal.staff;\n    for (const dayObj of staffCal.days) {\n      const date = dayObj.date;\n      const candidates = dayObj.candidates || [];\n\n      for (const candidate of candidates) {\n        allCandidates.push({\n          staff: staffName,\n          date: date,\n          start: candidate.start,\n          end: candidate.end,\n          qualityScore: candidate.qualityScore,\n          reasons: candidate.reasons,\n          constraints: candidate.constraints,\n          workHours: `${dayObj.work_start}-${dayObj.work_end}`\n        });\n      }\n    }\n  }\n\n  // âœ… SORT BY DATE FIRST (earliest to latest), then time, then score\n  allCandidates.sort((a, b) => {\n    // 1. Date (earliest first)\n    if (a.date !== b.date) return a.date.localeCompare(b.date);\n    // 2. Start time (earliest first)\n    if (a.start !== b.start) return a.start.localeCompare(b.start);\n    // 3. Quality score (highest first)\n    return b.qualityScore - a.qualityScore;\n  });\n\n  console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š æ‰å¹³åŒ–ç¸½å€™é¸: ${allCandidates.length} å€‹`);\n  if (allCandidates.length > 0) {\n    console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š æœ€æ—©æ—¥æœŸ: ${allCandidates[0].date}`);\n    console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š æœ€æ™šæ—¥æœŸ: ${allCandidates[allCandidates.length - 1].date}`);\n  }\n\n  // Group by staff + date\n  const groupedByStaffDate = {};\n  for (const candidate of allCandidates) {\n    const key = `${candidate.staff}|${candidate.date}`;\n    if (!groupedByStaffDate[key]) groupedByStaffDate[key] = [];\n    groupedByStaffDate[key].push(candidate);\n  }\n\n  // âœ… Limit to MAX 2 slots per staff per day\n  const limitedCandidates = [];\n  let totalFiltered = 0;\n\n  for (const [key, candidates] of Object.entries(groupedByStaffDate)) {\n    // Sort by time within each staff+date group\n    candidates.sort((a, b) => {\n      if (a.start !== b.start) return a.start.localeCompare(b.start);\n      return b.qualityScore - a.qualityScore;\n    });\n\n    // Take top 2 per staff per day\n    const topCandidates = candidates.slice(0, MAX_SLOTS_PER_STAFF_PER_DAY);\n    limitedCandidates.push(...topCandidates);\n\n    const filtered = candidates.length - topCandidates.length;\n    if (filtered > 0) {\n      totalFiltered += filtered;\n      console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š ${key}: ä¿ç•™ ${topCandidates.length} å€‹æ™‚æ®µ, éæ¿¾ ${filtered} å€‹`);\n    }\n  }\n\n  // âœ… Sort again by date (earliest first) after limiting\n  limitedCandidates.sort((a, b) => {\n    if (a.date !== b.date) return a.date.localeCompare(b.date);\n    if (a.start !== b.start) return a.start.localeCompare(b.start);\n    return b.qualityScore - a.qualityScore;\n  });\n\n  // âœ… Take TOP 20 candidates (date-sorted)\n  const topNCandidates = limitedCandidates.slice(0, TOP_N_CANDIDATES);\n  const additionalFiltered = limitedCandidates.length - topNCandidates.length;\n\n  console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š é™åˆ¶å¾Œç¸½å€™é¸: ${limitedCandidates.length} å€‹`);\n  console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š é€çµ¦AIçš„å‰ ${TOP_N_CANDIDATES} å€‹å€™é¸: ${topNCandidates.length} å€‹`);\n  console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š éæ¿¾çµ±è¨ˆ:`);\n  console.log(`   - æ¯è·å“¡æ¯å¤©é™åˆ¶éæ¿¾: ${totalFiltered} å€‹`);\n  console.log(`   - TOP ${TOP_N_CANDIDATES} é™åˆ¶éæ¿¾: ${additionalFiltered} å€‹`);\n\n  if (topNCandidates.length > 0) {\n    console.log(`[4ï¸âƒ£ é™åˆ¶] ğŸ“Š å‰3åé è¦½ (æŒ‰æ—¥æœŸæ’åº):`);\n    topNCandidates.slice(0, 3).forEach((c, i) => {\n      console.log(`   ${i + 1}. ${c.date} ${c.start}-${c.end} | ${c.staff} | åˆ†æ•¸:${c.qualityScore}`);\n    });\n  }\n\n  results.push({\n    json: {\n      ...json,\n      allCandidates: topNCandidates,  // Date-sorted, top 20\n      allCandidatesBeforeLimit: allCandidates.length,\n      filterMeta: {\n        processedAt: new Date().toISOString(),\n        ruleVersion: \"1.8-date-first-sorting\",\n        totalCandidates: topNCandidates.length,\n        filteredBySlotLimit: totalFiltered,\n        filteredByTopN: additionalFiltered,\n        maxSlotsPerStaffPerDay: MAX_SLOTS_PER_STAFF_PER_DAY,\n        topNCandidates: TOP_N_CANDIDATES,\n        sortOrder: \"date (earliest first), then time, then score\"\n      }\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18752,
        13952
      ],
      "id": "3b84bc0b-f31a-4d39-8aba-f1699a94d7cf",
      "name": "4ï¸âƒ£ é™åˆ¶å€™é¸æ•¸é‡"
    },
    {
      "parameters": {
        "jsCode": "// ğŸ¯ Filter Staff by Capability (Priority #1) - WITH SKILL MATCH QUALITY\n// âœ… UPDATED v3: Changed from HARD filter to SOFT filter with penalty tracking\n\nconst items = $input.all();\nconst results = [];\n\nfor (const item of items) {\n  const json = item.json;\n  const freeSlotsCalendar = json.freeSlotsCalendar || [];\n  const capabilityMap = json.capabilityMap || {};\n  const requestedService = json['æœå‹™'] || json['æœå‹™é …ç›®'] || '';\n  const currentServiceConfig = json.currentServiceConfig || {};\n  const supervisorList = json.supervisorList || [];\n\n  console.log('[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] ========== Priority #1 Filter ==========');\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] è«‹æ±‚çš„æœå‹™: ${requestedService}`);\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] è·å“¡ç¸½æ•¸: ${freeSlotsCalendar.length}`);\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] ç›£å·¥è·å“¡: ${supervisorList.length}ä½`);\n\n  // Filter 4: Check if service requires supervisor\n  const requiresSupervisor = currentServiceConfig.requires_supervisor || false;\n  const isGeneralCleaning = currentServiceConfig.is_general_cleaning || false;\n\n  if (requiresSupervisor) {\n    console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] ğŸ‘· æœå‹™ã€Œ${requestedService}ã€éœ€è¦ç›£å·¥åˆè¨ªåŠå›è¨ª`);\n  }\n  if (isGeneralCleaning) {\n    console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] ğŸ§¹ æœå‹™ã€Œ${requestedService}ã€æ˜¯ä¸€èˆ¬æ¸…æ½”ï¼Œä¸éœ€ç›£å·¥`);\n  }\n\n  // Cleaning service patterns\n  const CLEANING_PATTERNS = /æ¸…æ½”|æ¸…[ğŸ§¹]?$|è£æ¸…|å…¥æ¸…|å‰æ¸…|æ·±æ¸…|Clean/i;\n  const isCleaningServiceRequest = CLEANING_PATTERNS.test(requestedService);\n\n  // âœ… NEW: Specific cleaning service patterns for exact matching\n  const SPECIFIC_CLEANING = {\n    'è£ä¿®å¾Œæ¸…æ½”': /è£ä¿®å¾Œæ¸…æ½”|è£æ¸…/i,\n    'å…¥ä¼™å‰æ¸…æ½”': /å…¥ä¼™å‰æ¸…æ½”|å…¥æ¸…/i,\n    'å‰å±‹æ¸…æ½”': /å‰å±‹æ¸…æ½”|å‰æ¸…/i,\n    'æ·±å±¤æ¸…æ½”': /æ·±å±¤æ¸…æ½”|æ·±æ¸…/i,\n    'å®šæœŸæ¸…æ½”': /å®šæœŸæ¸…æ½”|ä¸€èˆ¬.*æ¸…æ½”|å®¶å±….*æ¸…æ½”/i\n  };\n\n  if (isCleaningServiceRequest) {\n    console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] ğŸ§¹ åµæ¸¬åˆ°æ¸…æ½”é¡æœå‹™: ${requestedService}`);\n  }\n\n  // âœ… NEW: Get match quality for skill matching\n  function getMatchQuality(capability, requested) {\n    if (!capability || !requested) return 'none';\n\n    const capLower = String(capability).toLowerCase().trim();\n    const reqLower = String(requested).toLowerCase().trim();\n\n    // Exact match (100%)\n    if (capLower === reqLower) return 'exact';\n\n    // âœ… IMPROVED: For cleaning services, check specific type match\n    if (isCleaningServiceRequest && CLEANING_PATTERNS.test(capLower)) {\n      // Check if both capability and requested service match the SAME specific cleaning type\n      for (const [serviceName, pattern] of Object.entries(SPECIFIC_CLEANING)) {\n        const capMatches = pattern.test(capLower);\n        const reqMatches = pattern.test(reqLower);\n\n        if (capMatches && reqMatches) {\n          // Both match the same specific cleaning type = exact match\n          console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âœ… ç²¾ç¢ºæ¸…æ½”æœå‹™åŒ¹é…: ${capability} â†” ${requested} (${serviceName})`);\n          return 'exact';\n        }\n      }\n\n      // Staff has SOME cleaning capability, but not the exact type = partial match\n      console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âš ï¸ éƒ¨åˆ†æ¸…æ½”æœå‹™åŒ¹é…: ${capability} â†” ${requested} (ä¸åŒé¡å‹)`);\n      return 'partial';\n    }\n\n    // Contains match (may be partial)\n    if (capLower.includes(reqLower) || reqLower.includes(capLower)) return 'exact';\n\n    // Remove common suffixes and try again\n    const capBase = capLower.replace(/(æœå‹™|é˜²æ²»|ç§»é™¤)$/g, '').trim();\n    const reqBase = reqLower.replace(/(æœå‹™|é˜²æ²»|ç§»é™¤)$/g, '').trim();\n\n    if (capBase && reqBase && capBase.length > 0 && reqBase.length > 0) {\n      if (capBase === reqBase || capBase.includes(reqBase) || reqBase.includes(capBase)) {\n        return 'exact';\n      }\n    }\n\n    return 'none';\n  }\n\n  // Filter 4: Check if staff has supervisor capability\n  function hasSupervisorCapability(staffName) {\n    const capabilities = capabilityMap[staffName] || [];\n    return capabilities.some(cap =>\n      /ç›£å·¥|ä¸»ç®¡|Supervisor|åˆè¨ª|å›è¨ª/i.test(cap)\n    );\n  }\n\n  // âœ… CHANGED: Pass through all staff but track skill match quality\n  const filteredCalendar = freeSlotsCalendar.map(staffCal => {\n    const staffName = staffCal.staff;\n    const capabilities = capabilityMap[staffName];\n\n    // Default: no skill requirement\n    let skillMatchQuality = 'exact';\n    let matchedCapability = null;\n\n    // If no service specified, perfect match\n    if (!requestedService || !requestedService.trim()) {\n      console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âœ… ${staffName}: ç„¡æœå‹™é™åˆ¶`);\n      return { ...staffCal, _skillMatchQuality: 'exact' };\n    }\n\n    // FALLBACK: If no capabilityMap at all, allow all staff\n    if (Object.keys(capabilityMap).length === 0) {\n      console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âš ï¸ ${staffName}: capabilityMapç‚ºç©ºï¼Œå…è¨±æ‰€æœ‰è·å“¡`);\n      return { ...staffCal, _skillMatchQuality: 'exact' };\n    }\n\n    // If staff has no capabilities listed, mark as 'none'\n    if (!capabilities || capabilities.length === 0) {\n      console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âŒ ${staffName}: ç„¡æŠ€èƒ½åˆ—è¡¨ â†’ æ¨™è¨˜ç‚º none`);\n      return { ...staffCal, _skillMatchQuality: 'none', _noSkillsListed: true };\n    }\n\n    // Filter 4: Check supervisor requirement (HARD filter - still reject)\n    if (requiresSupervisor) {\n      const anySupervisorsExist = supervisorList && supervisorList.length > 0;\n\n      if (anySupervisorsExist) {\n        const isSupervisor = hasSupervisorCapability(staffName);\n        if (!isSupervisor) {\n          console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âŒ ${staffName}: æœå‹™éœ€è¦ç›£å·¥èƒ½åŠ›ï¼Œä½†è·å“¡ç„¡æ­¤è³‡æ ¼ â†’ æ¨™è¨˜ç‚º none`);\n          return { ...staffCal, _skillMatchQuality: 'none', _missingSupervisor: true };\n        }\n        console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âœ… ${staffName}: å…·å‚™ç›£å·¥è³‡æ ¼`);\n      } else {\n        console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âš ï¸ ç³»çµ±ç„¡ç›£å·¥è·å“¡ï¼Œæ”¹ç‚ºæª¢æŸ¥æœå‹™æŠ€èƒ½åŒ¹é…`);\n      }\n    }\n\n    // âœ… NEW: Check skill match quality (not binary yes/no)\n    let bestMatchQuality = 'none';\n\n    for (const capability of capabilities) {\n      const matchQuality = getMatchQuality(capability, requestedService);\n\n      if (matchQuality === 'exact') {\n        bestMatchQuality = 'exact';\n        matchedCapability = capability;\n        console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âœ… ${staffName}: å…·å‚™ \"${capability}\" (ç²¾ç¢ºåŒ¹é…)`);\n        break;  // Found exact match, no need to check others\n      } else if (matchQuality === 'partial' && bestMatchQuality !== 'exact') {\n        bestMatchQuality = 'partial';\n        matchedCapability = capability;\n        console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âš ï¸ ${staffName}: å…·å‚™ \"${capability}\" (éƒ¨åˆ†åŒ¹é…ï¼Œå°‡æ‰£åˆ†)`);\n      }\n    }\n\n    if (bestMatchQuality === 'none') {\n      console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] âŒ ${staffName}: ä¸å…·å‚™ \"${requestedService}\"ï¼ŒæŠ€èƒ½: [${capabilities.join(', ')}] (å°‡å¤§å¹…æ‰£åˆ†)`);\n    }\n\n    return {\n      ...staffCal,\n      _skillMatchQuality: bestMatchQuality,\n      _matchedCapability: matchedCapability\n    };\n  });\n\n  // âœ… CHANGED: No longer filter out staff, just track match quality\n  const stats = {\n    exact: filteredCalendar.filter(s => s._skillMatchQuality === 'exact').length,\n    partial: filteredCalendar.filter(s => s._skillMatchQuality === 'partial').length,\n    none: filteredCalendar.filter(s => s._skillMatchQuality === 'none').length\n  };\n\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] çµæœ: ${filteredCalendar.length} ä½è·å“¡`);\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›]   - ç²¾ç¢ºåŒ¹é…: ${stats.exact} ä½`);\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›]   - éƒ¨åˆ†åŒ¹é… (å°‡æ‰£100åˆ†): ${stats.partial} ä½`);\n  console.log(`[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›]   - ç„¡åŒ¹é… (å°‡æ‰£200åˆ†): ${stats.none} ä½`);\n  console.log('[ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›] ========== Filter Complete ==========');\n\n  results.push({\n    json: {\n      ...json,\n      freeSlotsCalendar: filteredCalendar,\n      _capabilityFilterApplied: true,\n      _skillMatchStats: stats,\n      _supervisorFilterApplied: requiresSupervisor\n    }\n  });\n}\n\nreturn results;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18752,
        13568
      ],
      "id": "b5d0c172-165c-4a90-ace9-2cba3390bb71",
      "name": "ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›"
    },
    {
      "parameters": {
        "jsCode": "// â±ï¸ è¨ˆç®—å–®èˆ‡å–®è¡Œè»Šæ™‚é–“ (Filter 2)\n// ç›®çš„ï¼šå»ºç«‹æ¯ä½è·å“¡ç•¶å¤©å·¥ä½œçš„è¡Œè»Šæ™‚é–“æ˜ å°„ï¼Œç”¨æ–¼é©—è­‰å–®èˆ‡å–®ä¹‹é–“çš„ç·©è¡æ™‚é–“\n\nconst items = $input.all();\nconst results = [];\n\nconst Helpers = {\n  toMin: (timeStr) => {\n    if (!timeStr) return null;\n    const [h, m] = String(timeStr).split(':').map(Number);\n    return h * 60 + m;\n  },\n  fromMin: (minutes) => {\n    const h = Math.floor(minutes / 60).toString().padStart(2, '0');\n    const m = (minutes % 60).toString().padStart(2, '0');\n    return `${h}:${m}`;\n  }\n};\n\nfor (const item of items) {\n  const json = item.json;\n  const machineData = json.machineData || [];\n  const historyByStaffDate = json.historyByStaffDate || {};\n  \n  console.log('[â±ï¸ è¨ˆç®—å–®èˆ‡å–®] ========== é–‹å§‹è™•ç† ==========');\n  \n  // ========================================\n  // å»ºç«‹è·å“¡æ¯æ—¥å·¥ä½œè¡Œè»Šæ™‚é–“æ˜ å°„\n  // ========================================\n  const jobTravelMap = {};\n  \n  for (const apt of machineData) {\n    if (!apt || !apt.staff) continue;\n    \n    const staffNames = String(apt.staff).split(/[+ï¼‹]/).map(s => s.trim()).filter(Boolean);\n    const date = apt.start_at ? apt.start_at.split('T')[0] : null;\n    if (!date) continue;\n    \n    for (const staffName of staffNames) {\n      const key = `${staffName}|${date}`;\n      if (!jobTravelMap[key]) jobTravelMap[key] = [];\n      \n      // è§£ææ™‚é–“\n      const startTime = apt.start_at ? apt.start_at.substring(11, 16) : null;\n      const endTime = apt.end_at ? apt.end_at.substring(11, 16) : null;\n      \n      jobTravelMap[key].push({\n        id: apt.id,\n        start: apt.start_at,\n        end: apt.end_at,\n        startMin: Helpers.toMin(startTime),\n        endMin: Helpers.toMin(endTime),\n        district: apt.service_district,\n        service: apt.service,\n        // è¡Œè»Šæ™‚é–“è³‡æ–™\n        prevTravel: apt.prev?.drive_minutes || null,\n        nextTravel: apt.next?.drive_minutes || null,\n        prevDistrict: apt.prev?.district || null,\n        nextDistrict: apt.next?.district || null\n      });\n    }\n  }\n  \n  // æŒ‰é–‹å§‹æ™‚é–“æ’åºæ¯å€‹è·å“¡æ¯å¤©çš„å·¥ä½œ\n  for (const key of Object.keys(jobTravelMap)) {\n    jobTravelMap[key].sort((a, b) => {\n      const aTime = a.startMin || 0;\n      const bTime = b.startMin || 0;\n      return aTime - bTime;\n    });\n  }\n  \n  console.log(`[â±ï¸ è¨ˆç®—å–®èˆ‡å–®] ğŸ“Š å»ºç«‹äº† ${Object.keys(jobTravelMap).length} å€‹è·å“¡-æ—¥æœŸçµ„åˆ`);\n  \n  // ========================================\n  // è¨ˆç®—æ¯å°ç›¸é„°å·¥ä½œä¹‹é–“çš„é–“éš”å’Œè¡Œè»Šæ™‚é–“\n  // ========================================\n  const jobGapAnalysis = {};\n  \n  for (const [key, jobs] of Object.entries(jobTravelMap)) {\n    if (jobs.length < 2) continue;\n    \n    const gaps = [];\n    for (let i = 0; i < jobs.length - 1; i++) {\n      const currentJob = jobs[i];\n      const nextJob = jobs[i + 1];\n      \n      if (currentJob.endMin && nextJob.startMin) {\n        const gapMinutes = nextJob.startMin - currentJob.endMin;\n        const travelTime = nextJob.prevTravel || currentJob.nextTravel || 15; // é è¨­15åˆ†é˜\n        const bufferNeeded = travelTime + 30; // è¡Œè»Šæ™‚é–“ + 30åˆ†é˜ç·©è¡\n        const isSufficient = gapMinutes >= bufferNeeded;\n        \n        gaps.push({\n          fromJob: currentJob.id,\n          toJob: nextJob.id,\n          fromEnd: Helpers.fromMin(currentJob.endMin),\n          toStart: Helpers.fromMin(nextJob.startMin),\n          gapMinutes,\n          travelTime,\n          bufferNeeded,\n          isSufficient,\n          fromDistrict: currentJob.district,\n          toDistrict: nextJob.district\n        });\n        \n        if (!isSufficient) {\n          console.log(`[â±ï¸ è¨ˆç®—å–®èˆ‡å–®] âš ï¸ ${key}: é–“éš”ä¸è¶³ï¼`);\n          console.log(`   ${Helpers.fromMin(currentJob.endMin)} â†’ ${Helpers.fromMin(nextJob.startMin)}`);\n          console.log(`   é–“éš”: ${gapMinutes}åˆ†, éœ€è¦: ${bufferNeeded}åˆ† (è¡Œè»Š${travelTime}åˆ†+ç·©è¡30åˆ†)`);\n        }\n      }\n    }\n    \n    if (gaps.length > 0) {\n      jobGapAnalysis[key] = gaps;\n    }\n  }\n  \n  console.log(`[â±ï¸ è¨ˆç®—å–®èˆ‡å–®] ğŸ“Š åˆ†æäº† ${Object.keys(jobGapAnalysis).length} å€‹æœ‰å¤šå–®çš„è·å“¡-æ—¥æœŸçµ„åˆ`);\n  console.log('[â±ï¸ è¨ˆç®—å–®èˆ‡å–®] ========== è™•ç†å®Œæˆ ==========');\n  \n  results.push({\n    json: {\n      ...json,\n      jobTravelMap,\n      jobGapAnalysis\n    }\n  });\n}\n\nreturn results;\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18752,
        13376
      ],
      "id": "17aff467-f19a-4cc8-84c4-cf9a4c19d05e",
      "name": "â±ï¸ è¨ˆç®—å–®èˆ‡å–®è¡Œè»Šæ™‚é–“"
    },
    {
      "parameters": {
        "jsCode": "// Debug: Check what data is being passed to è·å“¡åœ°å€\nconst inputData = $input.first().json;\n\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] ========== START ==========');\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] Input keys:', Object.keys(inputData || {}).slice(0, 20).join(', '));\n\nconst staffList = inputData?.staffList || [];\nconst staffCfg = inputData?.staffCfg || {};\n\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] staffList length:', staffList.length);\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] staffList type:', typeof staffList[0]);\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] staffList sample:', JSON.stringify(staffList.slice(0, 3)));\n\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] staffCfg keys:', Object.keys(staffCfg).length);\n\n// Check each staff's address\nconst addressCheck = [];\nfor (const staff of staffList.slice(0, 10)) {\n  const staffName = typeof staff === 'string' ? staff : (staff?.name || '');\n  const cfg = staffCfg[staffName] || {};\n  const homeDistrict = cfg.home_district || '(missing)';\n  addressCheck.push(`${staffName}: ${homeDistrict}`);\n}\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] Address check:', addressCheck.join(', '));\n\n// Build what origins would look like\nconst INVALID_PATTERNS = [\n  /^ä¸é©ç”¨$/i,\n  /^n\\/a$/i,\n  /^null$/i,\n  /^undefined$/i,\n  /^ç„¡$/i,\n  /^æ²’æœ‰$/i,\n  /^-$/,\n  /^\\.$/\n];\n\nconst isInvalidAddress = (addr) => {\n  if (!addr || typeof addr !== 'string') return true;\n  const trimmed = addr.trim();\n  if (!trimmed || trimmed.length < 2) return true;\n  return INVALID_PATTERNS.some(pattern => pattern.test(trimmed));\n};\n\nconst validAddresses = [];\nfor (const staff of staffList) {\n  const staffName = typeof staff === 'string' ? staff : (staff?.name || '');\n  const cfg = staffCfg[staffName] || {};\n  const raw = cfg.home_district || '';\n\n  if (!isInvalidAddress(raw)) {\n    const cleaned = raw.replace(/^(é¦™æ¸¯å³¶|ä¹é¾|æ–°ç•Œ)/, '').trim();\n    if (cleaned) {\n      validAddresses.push(`${staffName}: ${cleaned}`);\n    }\n  }\n}\n\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] Valid addresses:', validAddresses.length);\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] Valid address list:', validAddresses.join(' | '));\nconsole.log('[DEBUG è·å“¡åœ°å€è¼¸å…¥] ========== END ==========');\n\n// Pass through unchanged\nreturn $input.all();\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18080,
        13056
      ],
      "id": "0bf460e6-f55f-4a23-a8e3-adef6fe8a728",
      "name": "Debug è·å“¡åœ°å€è¼¸å…¥"
    },
    {
      "parameters": {
        "jsCode": "// æº–å‚™ Google Maps Distance Matrix API åƒæ•¸\n// âš ï¸ ä¸è¦ URL encodeï¼è®“ n8n HTTP Request node è™•ç†ç·¨ç¢¼\n// âœ… UPDATED: Store staffOrder for index-based matching\n\nconst inputData = $input.first().json;\n\nconsole.log('[æº–å‚™åœ°åœ–åƒæ•¸] ========== START ==========');\n\n// ========================================\n// 1. æº–å‚™ Origins (è·å“¡ä½å€)\n// ========================================\nconst staffList = Array.isArray(inputData?.staffList) ? inputData.staffList : [];\nconst staffCfg = inputData?.staffCfg || {};\n\nconsole.log('[æº–å‚™åœ°åœ–åƒæ•¸] staffList length:', staffList.length);\nconsole.log('[æº–å‚™åœ°åœ–åƒæ•¸] staffCfg keys:', Object.keys(staffCfg).length);\n\n// Invalid address patterns\nconst INVALID_PATTERNS = [\n  /^ä¸é©ç”¨$/i,\n  /^n\\/?a$/i,\n  /^null$/i,\n  /^undefined$/i,\n  /^ç„¡$/i,\n  /^æ²’æœ‰$/i,\n  /^-$/,\n  /^\\.$/\n];\n\nconst isInvalidAddress = (addr) => {\n  if (!addr || typeof addr !== 'string') return true;\n  const trimmed = addr.trim();\n  if (!trimmed || trimmed.length < 2) return true;\n  return INVALID_PATTERNS.some(pattern => pattern.test(trimmed));\n};\n\nconst validAddresses = [];\nconst addressToStaffMap = {};\nconst staffOrder = [];  // âœ… NEW: Ordered list of staff names (same order as addresses)\n\nfor (const staff of staffList) {\n  const staffName = typeof staff === 'string' ? staff : (staff?.name || '');\n  const cfg = staffCfg[staffName] || {};\n  const raw = cfg.home_district || '';\n\n  if (!isInvalidAddress(raw)) {\n    // Clean address: remove region prefix, add \", Hong Kong\"\n    let cleaned = raw.replace(/^(é¦™æ¸¯å³¶|ä¹é¾|æ–°ç•Œ)/, '').trim();\n    if (cleaned && !isInvalidAddress(cleaned)) {\n      const finalAddr = cleaned.includes('Hong Kong') ? cleaned : `${cleaned}, Hong Kong`;\n      validAddresses.push(finalAddr);\n      addressToStaffMap[finalAddr] = staffName;\n      staffOrder.push(staffName);  // âœ… NEW: Store staff name in order\n      console.log(`[æº–å‚™åœ°åœ–åƒæ•¸] âœ… ${staffName}: \"${finalAddr}\"`);\n    }\n  } else {\n    console.log(`[æº–å‚™åœ°åœ–åƒæ•¸] âš ï¸ ${staffName}: invalid address \"${raw}\"`);\n  }\n}\n\n// Build origins string - pipe-separated, NO URL encoding (n8n will handle it)\nlet originsString = '';\nif (validAddresses.length > 0) {\n  originsString = validAddresses.join('|');\n  console.log('[æº–å‚™åœ°åœ–åƒæ•¸] âœ… Origins count:', validAddresses.length);\n  console.log('[æº–å‚™åœ°åœ–åƒæ•¸] ğŸ“¤ Origins (raw):', originsString);\n  console.log('[æº–å‚™åœ°åœ–åƒæ•¸] ğŸ“‹ Staff order:', staffOrder.join(', '));\n} else {\n  originsString = 'Hong Kong';\n  console.log('[æº–å‚™åœ°åœ–åƒæ•¸] âš ï¸ No valid origins, using fallback: Hong Kong');\n}\n\n// ========================================\n// 2. æº–å‚™ Destinations (æœå‹™åœ°é»)\n// ========================================\nlet area = inputData?.serviceDistrict || inputData?.district || inputData['åœ°å€'] || '';\n\nif (!area || typeof area !== 'string') {\n  area = 'Hong Kong';\n  console.log('[æº–å‚™åœ°åœ–åƒæ•¸] âš ï¸ No service district, using fallback: Hong Kong');\n} else {\n  // Clean area\n  area = area.replace(/^(é¦™æ¸¯å³¶|ä¹é¾|æ–°ç•Œ)/, '').trim();\n  if (!area) {\n    area = 'Hong Kong';\n  } else if (!/hong\\s*kong$/i.test(area)) {\n    area = `${area}, Hong Kong`;\n  }\n  console.log('[æº–å‚™åœ°åœ–åƒæ•¸] âœ… Destination:', area);\n}\n\n// NO URL encoding - n8n will handle it\nconst destinationsString = area;\n\nconsole.log('[æº–å‚™åœ°åœ–åƒæ•¸] ğŸ“¤ Destinations (raw):', destinationsString);\nconsole.log('[æº–å‚™åœ°åœ–åƒæ•¸] ========== END ==========');\n\n// Return all original data plus the prepared params\nreturn [{\n  json: {\n    ...inputData,\n    _mapsParams: {\n      origins: originsString,\n      destinations: destinationsString,\n      validAddressCount: validAddresses.length,\n      addressToStaffMap: addressToStaffMap,\n      staffOrder: staffOrder  // âœ… NEW: Ordered list for index-based matching\n    }\n  }\n}];\n"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        18304,
        13056
      ],
      "id": "da532d34-9059-45b6-bf61-660a5524cbca",
      "name": "æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸"
    },
    {
      "parameters": {
        "modelName": "models/gemini-2.5-flash-lite",
        "options": {}
      },
      "type": "@n8n/n8n-nodes-langchain.lmChatGoogleGemini",
      "typeVersion": 1,
      "position": [
        19392,
        13232
      ],
      "id": "fdfcf99e-5bc9-4241-a247-d05548188fd0",
      "name": "Google Gemini Chat Model",
      "credentials": {
        "googlePalmApi": {
          "id": "QhNUnhFx3MlmpGkD",
          "name": "Google Gemini-(Sharing)"
        }
      }
    }
  ],
  "pinData": {},
  "connections": {
    "Validate Input": {
      "main": [
        [
          {
            "node": "æŠ½å‡ºå¿…è¦å­—æ®µ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Set System Prompt": {
      "main": [
        [
          {
            "node": "AI Agent",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "å®¢æˆ¶é ç´„è«‹æ±‚": {
      "main": [
        [],
        [
          {
            "node": "Validate Input",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "è·å“¡åœ°å€": {
      "main": [
        [
          {
            "node": "åˆä½µåœ°åœ–èˆ‡è·å“¡è³‡æ–™",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æŠ½å‡ºå¿…è¦å­—æ®µ": {
      "main": [
        [
          {
            "node": "ç²å–æœªä¾†7D CRMæ’ç¨‹",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æ‹†åˆ†å‡ºæ¯å€‹é ç´„": {
      "main": [
        [
          {
            "node": "CRM-æŠ½å‡ºå¿…è¦å­—æ®µ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "CRM-æŠ½å‡ºå¿…è¦å­—æ®µ": {
      "main": [
        [
          {
            "node": "è·é›¢çŸ©é™£æ‰¹æ¬¡",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ç²å–æœªä¾†7D CRMæ’ç¨‹": {
      "main": [
        [
          {
            "node": "æ‹†åˆ†å‡ºæ¯å€‹é ç´„",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½": {
      "main": [
        [
          {
            "node": "Debug è·å“¡åœ°å€è¼¸å…¥",
            "type": "main",
            "index": 0
          },
          {
            "node": "åˆä½µåœ°åœ–èˆ‡è·å“¡è³‡æ–™",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "åˆ¤æ–·å›è¨ªé ç´„": {
      "main": [
        [
          {
            "node": "æ•´åˆé ç´„è³‡æ–™",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "è·é›¢çŸ©é™£æ‰¹æ¬¡": {
      "main": [
        [
          {
            "node": "åˆ¤æ–·å›è¨ªé ç´„",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æ•´åˆé ç´„è³‡æ–™": {
      "main": [
        [
          {
            "node": "å¾é ç´„æå–è·å“¡è³‡æ–™",
            "type": "main",
            "index": 0
          },
          {
            "node": "åˆä½µCRMè³‡æ–™",
            "type": "main",
            "index": 0
          },
          {
            "node": "Staff_Config",
            "type": "main",
            "index": 0
          },
          {
            "node": "Service_Config",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "AI Agent": {
      "main": [
        [
          {
            "node": "è§£æä¸¦æ ¼å¼åŒ–AIè¼¸å‡º",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "å¾é ç´„æå–è·å“¡è³‡æ–™": {
      "main": [
        [
          {
            "node": "åˆä½µCRMè³‡æ–™",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "åˆä½µCRMè³‡æ–™": {
      "main": [
        [
          {
            "node": "åˆä½µCRMè³‡æ–™1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Staff_Config": {
      "main": [
        [
          {
            "node": "æ•´ç†Googleè·å“¡è³‡æ–™",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Service_Config": {
      "main": [
        [
          {
            "node": "åˆä½µServiceè¨­å®š",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "åˆä½µServiceè¨­å®š": {
      "main": [
        [
          {
            "node": "åˆä½µStaffè¨­å®š",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "åˆä½µStaffè¨­å®š": {
      "main": [
        [
          {
            "node": "æŠŠè³‡æ–™è½‰åˆ°AI agentå‹å¥½",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æ•´ç†è·å“¡é€šå‹¤æ‘˜è¦": {
      "main": [
        [
          {
            "node": "1ï¸âƒ£ å»ºç«‹é…ç½®æ˜ å°„",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "åˆä½µåœ°åœ–èˆ‡è·å“¡è³‡æ–™": {
      "main": [
        [
          {
            "node": "æ•´ç†è·å“¡é€šå‹¤æ‘˜è¦",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æ•´ç†Googleè·å“¡è³‡æ–™": {
      "main": [
        [
          {
            "node": "åˆä½µCRMè³‡æ–™1",
            "type": "main",
            "index": 1
          }
        ]
      ]
    },
    "åˆä½µCRMè³‡æ–™1": {
      "main": [
        [
          {
            "node": "åˆä½µServiceè¨­å®š",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "è§£æä¸¦æ ¼å¼åŒ–AIè¼¸å‡º": {
      "main": [
        [
          {
            "node": "Respond to Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "1ï¸âƒ£ å»ºç«‹é…ç½®æ˜ å°„": {
      "main": [
        [
          {
            "node": "2ï¸âƒ£ å»ºç«‹è·å“¡æ­·å²ç´¢å¼•",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "2ï¸âƒ£ å»ºç«‹è·å“¡æ­·å²ç´¢å¼•": {
      "main": [
        [
          {
            "node": "â±ï¸ è¨ˆç®—å–®èˆ‡å–®è¡Œè»Šæ™‚é–“",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "â±ï¸ è¨ˆç®—å–®èˆ‡å–®è¡Œè»Šæ™‚é–“": {
      "main": [
        [
          {
            "node": "ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾å€™é¸æ™‚æ®µ": {
      "main": [
        [
          {
            "node": "4ï¸âƒ£ é™åˆ¶å€™é¸æ•¸é‡",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "4ï¸âƒ£ é™åˆ¶å€™é¸æ•¸é‡": {
      "main": [
        [
          {
            "node": "Set System Prompt",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ğŸ¯ éæ¿¾è·å“¡èƒ½åŠ›": {
      "main": [
        [
          {
            "node": "3ï¸âƒ£ ç”Ÿæˆä¸¦éæ¿¾å€™é¸æ™‚æ®µ",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Debug è·å“¡åœ°å€è¼¸å…¥": {
      "main": [
        [
          {
            "node": "æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "æº–å‚™åœ°åœ–æŸ¥è©¢åƒæ•¸": {
      "main": [
        [
          {
            "node": "è·å“¡åœ°å€",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Google Gemini Chat Model": {
      "ai_languageModel": [
        [
          {
            "node": "AI Agent",
            "type": "ai_languageModel",
            "index": 0
          }
        ]
      ]
    }
  },
  "active": false,
  "settings": {
    "executionOrder": "v1"
  },
  "versionId": "a576750d-ea57-4996-a457-45458e6ebed0",
  "meta": {
    "templateCredsSetupCompleted": true,
    "instanceId": "a528359f5b4a907bcdbdb1bdd3512c336c95b86b14c52d72b4dcc06e771f42db"
  },
  "id": "6lWV3y4d8d3TrpmN",
  "tags": []
}